// PythonThreadStateManager_Complete.h - Complete implementation with all methods
#pragma once

#include "IPythonEnvironment.h"
#include <Windows.h>
#include <unordered_map>
#include <memory>
#include <atomic>
#include <chrono>
#include <queue>
#include <condition_variable>

// Forward declare Python types (avoid Python.h in header)
struct _ts;  // PyThreadState
struct _is;  // PyInterpreterState
typedef struct _ts PyThreadState;
typedef struct _is PyInterpreterState;
typedef struct _object PyObject;

// GIL State enum (matching Python's definition)
enum { PyGILState_LOCKED, PyGILState_UNLOCKED };

// Complete Thread State Manager Implementation
class PythonThreadStateManager {
public:
    struct ThreadStateInfo {
        PyThreadState* pyThreadState;
        PyInterpreterState* pyInterpreterState;
        std::thread::id cppThreadId;
        DWORD windowsThreadId;
        HANDLE threadHandle;
        bool isMainThread;
        bool isActive;
        std::chrono::system_clock::time_point createdAt;
        std::string threadName;
        
        // GIL state at capture time
        int gilState;
        bool hadGIL;
        
        ThreadStateInfo() 
            : pyThreadState(nullptr)
            , pyInterpreterState(nullptr)
            , windowsThreadId(0)
            , threadHandle(nullptr)
            , isMainThread(false)
            , isActive(true)
            , gilState(PyGILState_UNLOCKED)
            , hadGIL(false) {}
            
        ~ThreadStateInfo() {
            if (threadHandle) {
                CloseHandle(threadHandle);
                threadHandle = nullptr;
            }
        }
    };
    
private:
    // Thread state storage
    std::unordered_map<std::thread::id, std::unique_ptr<ThreadStateInfo>> m_threadStates;
    std::unordered_map<PyThreadState*, std::thread::id> m_pyStateToThread;
    
    // Main interpreter tracking
    PyInterpreterState* m_mainInterpreter = nullptr;
    PyThreadState* m_mainThreadState = nullptr;
    std::thread::id m_mainThreadId;
    
    // Synchronization
    mutable std::mutex m_mutex;
    std::atomic<bool> m_finalizationInProgress{false};
    
    // Task queue for cross-thread execution
    struct CrossThreadTask {
        std::function<void()> task;
        std::promise<bool> promise;
    };
    std::queue<CrossThreadTask> m_taskQueue;
    std::condition_variable m_taskCv;
    std::mutex m_taskMutex;
    
    // Python function pointers
    struct PythonAPI {
        // Thread state functions
        PyThreadState* (*PyThreadState_Get)(void) = nullptr;
        PyThreadState* (*PyThreadState_Swap)(PyThreadState*) = nullptr;
        void (*PyThreadState_Clear)(PyThreadState*) = nullptr;
        void (*PyThreadState_Delete)(PyThreadState*) = nullptr;
        PyThreadState* (*PyThreadState_New)(PyInterpreterState*) = nullptr;
        PyInterpreterState* (*PyThreadState_GetInterpreter)(PyThreadState*) = nullptr;
        void (*PyThreadState_DeleteCurrent)(void) = nullptr;
        
        // Interpreter functions
        PyInterpreterState* (*PyInterpreterState_Get)(void) = nullptr;
        PyInterpreterState* (*PyInterpreterState_Head)(void) = nullptr;
        PyInterpreterState* (*PyInterpreterState_Next)(PyInterpreterState*) = nullptr;
        PyThreadState* (*PyInterpreterState_ThreadHead)(PyInterpreterState*) = nullptr;
        
        // GIL functions
        void (*PyEval_RestoreThread)(PyThreadState*) = nullptr;
        PyThreadState* (*PyEval_SaveThread)(void) = nullptr;
        void (*PyEval_AcquireThread)(PyThreadState*) = nullptr;
        void (*PyEval_ReleaseThread)(PyThreadState*) = nullptr;
        int (*PyGILState_Ensure)(void) = nullptr;
        void (*PyGILState_Release)(int) = nullptr;
        int (*PyGILState_Check)(void) = nullptr;
        PyThreadState* (*PyGILState_GetThisThreadState)(void) = nullptr;
        
        // Thread management
        void (*PyThread_exit_thread)(void) = nullptr;
        unsigned long (*PyThread_get_thread_ident)(void) = nullptr;
        int (*PyThread_set_key_value)(int, void*) = nullptr;
        void* (*PyThread_get_key_value)(int) = nullptr;
        
        // Error handling
        void (*PyErr_Clear)(void) = nullptr;
        PyObject* (*PyErr_Occurred)(void) = nullptr;
        void (*PyErr_Print)(void) = nullptr;
        
        bool LoadFromDll(HMODULE pythonDll) {
            if (!pythonDll) return false;
            
            #define LOAD_FUNC(name) \
                name = (decltype(name))GetProcAddress(pythonDll, #name)
            
            // Essential functions
            LOAD_FUNC(PyThreadState_Get);
            LOAD_FUNC(PyThreadState_Swap);
            LOAD_FUNC(PyThreadState_Clear);
            LOAD_FUNC(PyThreadState_Delete);
            LOAD_FUNC(PyInterpreterState_Get);
            LOAD_FUNC(PyEval_RestoreThread);
            LOAD_FUNC(PyEval_SaveThread);
            
            // Optional functions
            LOAD_FUNC(PyThreadState_New);
            LOAD_FUNC(PyThreadState_GetInterpreter);
            LOAD_FUNC(PyThreadState_DeleteCurrent);
            LOAD_FUNC(PyInterpreterState_Head);
            LOAD_FUNC(PyInterpreterState_Next);
            LOAD_FUNC(PyInterpreterState_ThreadHead);
            LOAD_FUNC(PyEval_AcquireThread);
            LOAD_FUNC(PyEval_ReleaseThread);
            LOAD_FUNC(PyGILState_Ensure);
            LOAD_FUNC(PyGILState_Release);
            LOAD_FUNC(PyGILState_Check);
            LOAD_FUNC(PyGILState_GetThisThreadState);
            LOAD_FUNC(PyThread_exit_thread);
            LOAD_FUNC(PyThread_get_thread_ident);
            LOAD_FUNC(PyThread_set_key_value);
            LOAD_FUNC(PyThread_get_key_value);
            LOAD_FUNC(PyErr_Clear);
            LOAD_FUNC(PyErr_Occurred);
            LOAD_FUNC(PyErr_Print);
            
            #undef LOAD_FUNC
            
            // Check minimum required functions
            return PyThreadState_Get && PyThreadState_Swap && PyEval_SaveThread;
        }
    } m_api;
    
public:
    PythonThreadStateManager() = default;
    
    ~PythonThreadStateManager() {
        // Ensure all thread states are cleaned up
        ShutdownAllThreadStates();
    }
    
    bool Initialize(HMODULE pythonDll) {
        return m_api.LoadFromDll(pythonDll);
    }
    
    // Capture current thread state
    bool CaptureCurrentThreadState(bool isMainThread = false) {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (!m_api.PyThreadState_Get) {
            return false;
        }
        
        // Check if already captured
        auto currentThreadId = std::this_thread::get_id();
        if (m_threadStates.find(currentThreadId) != m_threadStates.end()) {
            return true;  // Already captured
        }
        
        auto info = std::make_unique<ThreadStateInfo>();
        info->cppThreadId = currentThreadId;
        info->windowsThreadId = GetCurrentThreadId();
        
        // Duplicate handle for cross-thread operations
        if (!DuplicateHandle(
            GetCurrentProcess(),
            GetCurrentThread(),
            GetCurrentProcess(),
            &info->threadHandle,
            THREAD_ALL_ACCESS,
            FALSE,
            0)) {
            info->threadHandle = nullptr;
        }
        
        info->isMainThread = isMainThread;
        info->createdAt = std::chrono::system_clock::now();
        
        // Get thread name (Windows 10+)
        GetThreadName(info->threadName);
        
        // Capture Python thread state
        PyThreadState* currentState = nullptr;
        try {
            currentState = m_api.PyThreadState_Get();
        } catch (...) {
            // PyThreadState_Get might throw if no thread state
            if (m_api.PyGILState_GetThisThreadState) {
                currentState = m_api.PyGILState_GetThisThreadState();
            }
        }
        
        if (!currentState) {
            return false;
        }
        
        info->pyThreadState = currentState;
        
        // Get interpreter state
        if (m_api.PyThreadState_GetInterpreter) {
            info->pyInterpreterState = m_api.PyThreadState_GetInterpreter(currentState);
        } else if (m_api.PyInterpreterState_Get) {
            info->pyInterpreterState = m_api.PyInterpreterState_Get();
        }
        
        // Check GIL state
        if (m_api.PyGILState_Check) {
            info->hadGIL = m_api.PyGILState_Check() == 1;
            info->gilState = info->hadGIL ? PyGILState_LOCKED : PyGILState_UNLOCKED;
        }
        
        // Store main thread info
        if (isMainThread) {
            m_mainThreadId = info->cppThreadId;
            m_mainThreadState = info->pyThreadState;
            m_mainInterpreter = info->pyInterpreterState;
        }
        
        // Add to maps
        m_pyStateToThread[info->pyThreadState] = info->cppThreadId;
        m_threadStates[info->cppThreadId] = std::move(info);
        
        return true;
    }
    
    // Optimal finalization using saved thread states
    bool FinalizeWithThreadState(std::function<void()> finalizer) {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_finalizationInProgress.exchange(true)) {
            return false;  // Already finalizing
        }
        
        auto currentThread = std::this_thread::get_id();
        auto it = m_threadStates.find(currentThread);
        
        if (it != m_threadStates.end() && it->second->pyThreadState) {
            // We have thread state for current thread
            return FinalizeOnCurrentThread(it->second.get(), finalizer);
        } else {
            // Need to finalize from different thread
            return FinalizeCrossThread(finalizer);
        }
    }
    
    // Ensure Python calls happen on correct thread
    template<typename Func>
    auto ExecuteOnPythonThread(Func&& func) -> decltype(func()) {
        auto currentThread = std::this_thread::get_id();
        
        std::lock_guard<std::mutex> lock(m_mutex);
        auto it = m_threadStates.find(currentThread);
        
        if (it != m_threadStates.end() && it->second->pyThreadState) {
            // Current thread has Python state, execute directly
            EnsureThreadState(it->second.get());
            return func();
        } else {
            // Need to switch to Python thread
            return ExecuteOnMainPythonThread(std::forward<Func>(func));
        }
    }
    
    // Clean shutdown of all thread states
    void ShutdownAllThreadStates() {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        // First, clear all non-main thread states
        for (auto& [threadId, info] : m_threadStates) {
            if (!info->isMainThread && info->pyThreadState && info->isActive) {
                ClearThreadState(info.get());
            }
        }
        
        // Then clear main thread state
        if (m_mainThreadState) {
            auto it = m_threadStates.find(m_mainThreadId);
            if (it != m_threadStates.end()) {
                ClearThreadState(it->second.get());
            }
        }
        
        // Clear all mappings
        m_threadStates.clear();
        m_pyStateToThread.clear();
        m_mainThreadState = nullptr;
        m_mainInterpreter = nullptr;
    }
    
    // Get thread state info
    const ThreadStateInfo* GetThreadStateInfo(std::thread::id threadId) const {
        std::lock_guard<std::mutex> lock(m_mutex);
        auto it = m_threadStates.find(threadId);
        return (it != m_threadStates.end()) ? it->second.get() : nullptr;
    }
    
    // Check if current thread has Python state
    bool CurrentThreadHasPythonState() const {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_threadStates.find(std::this_thread::get_id()) != m_threadStates.end();
    }
    
    // Get main thread ID
    std::thread::id GetMainThreadId() const {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_mainThreadId;
    }
    
    // Debug information
    void DumpThreadStates(std::ostream& out) const {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        out << "=== Python Thread States ===" << std::endl;
        out << "Total threads: " << m_threadStates.size() << std::endl;
        out << "Main thread: " << m_mainThreadId << std::endl;
        out << "Finalization in progress: " << m_finalizationInProgress << std::endl;
        
        for (const auto& [threadId, info] : m_threadStates) {
            out << "\nThread " << threadId << ":" << std::endl;
            out << "  Name: " << (info->threadName.empty() ? "<unnamed>" : info->threadName) << std::endl;
            out << "  Windows TID: " << info->windowsThreadId << std::endl;
            out << "  PyThreadState: " << info->pyThreadState << std::endl;
            out << "  PyInterpreterState: " << info->pyInterpreterState << std::endl;
            out << "  Is Main: " << (info->isMainThread ? "Yes" : "No") << std::endl;
            out << "  Is Active: " << (info->isActive ? "Yes" : "No") << std::endl;
            out << "  Had GIL: " << (info->hadGIL ? "Yes" : "No") << std::endl;
            
            auto now = std::chrono::system_clock::now();
            auto duration = std::chrono::duration_cast<std::chrono::seconds>(
                now - info->createdAt).count();
            out << "  Active for: " << duration << " seconds" << std::endl;
        }
    }
    
private:
    bool FinalizeOnCurrentThread(ThreadStateInfo* info, std::function<void()> finalizer) {
        // Ensure we have the right thread state
        EnsureThreadState(info);
        
        try {
            // Clear any pending Python errors
            if (m_api.PyErr_Clear) {
                m_api.PyErr_Clear();
            }
            
            // Execute finalization
            finalizer();
            
            // Mark thread state as inactive
            info->isActive = false;
            
            return true;
        } catch (const std::exception& e) {
            std::cerr << "Exception during finalization: " << e.what() << std::endl;
            return false;
        } catch (...) {
            std::cerr << "Unknown exception during finalization" << std::endl;
            return false;
        }
    }
    
    bool FinalizeCrossThread(std::function<void()> finalizer) {
        // Try to find a suitable thread with Python state
        ThreadStateInfo* targetThread = nullptr;
        
        // Prefer main thread
        if (m_mainThreadState) {
            auto it = m_threadStates.find(m_mainThreadId);
            if (it != m_threadStates.end() && it->second->isActive) {
                targetThread = it->second.get();
            }
        }
        
        // Or use any active thread with state
        if (!targetThread) {
            for (auto& [threadId, info] : m_threadStates) {
                if (info->isActive && info->pyThreadState) {
                    targetThread = info.get();
                    break;
                }
            }
        }
        
        if (!targetThread) {
            // No suitable thread found, try direct finalization with safety measures
            return FinalizeWithoutThreadState(finalizer);
        }
        
        // Execute on target thread
        return ExecuteOnThread(targetThread, finalizer);
    }
    
    bool FinalizeWithoutThreadState(std::function<void()> finalizer) {
        // Last resort - try to finalize safely without proper thread state
        
        // Acquire GIL if possible
        int gilState = -1;
        if (m_api.PyGILState_Ensure) {
            gilState = m_api.PyGILState_Ensure();
        }
        
        try {
            // Clear errors
            if (m_api.PyErr_Clear) {
                m_api.PyErr_Clear();
            }
            
            // Execute finalizer
            finalizer();
            
            // Release GIL
            if (gilState != -1 && m_api.PyGILState_Release) {
                m_api.PyGILState_Release(gilState);
            }
            
            return true;
        } catch (...) {
            // Release GIL even on error
            if (gilState != -1 && m_api.PyGILState_Release) {
                m_api.PyGILState_Release(gilState);
            }
            return false;
        }
    }
    
    void EnsureThreadState(ThreadStateInfo* info) {
        if (!info->pyThreadState || !m_api.PyThreadState_Swap) {
            return;
        }
        
        // Get current thread state
        PyThreadState* current = nullptr;
        try {
            current = m_api.PyThreadState_Get();
        } catch (...) {
            // No current thread state
        }
        
        if (current != info->pyThreadState) {
            // Need to swap thread state
            m_api.PyThreadState_Swap(info->pyThreadState);
        }
    }
    
    template<typename Func>
    auto ExecuteOnMainPythonThread(Func&& func) -> decltype(func()) {
        using ReturnType = decltype(func());
        
        if (!m_mainThreadState) {
            throw std::runtime_error("No main Python thread state available");
        }
        
        // Package the function
        std::packaged_task<ReturnType()> task(std::forward<Func>(func));
        auto future = task.get_future();
        
        // Queue for execution on main thread
        {
            std::lock_guard<std::mutex> lock(m_taskMutex);
            CrossThreadTask crossTask;
            crossTask.task = [&task]() { task(); };
            
            m_taskQueue.push(std::move(crossTask));
        }
        
        m_taskCv.notify_one();
        
        // Wait for result
        return future.get();
    }
    
    bool ExecuteOnThread(ThreadStateInfo* targetThread, std::function<void()> func) {
        if (!targetThread || !targetThread->threadHandle) {
            return false;
        }
        
        struct APCContext {
            std::function<void()>* func;
            std::atomic<bool> completed{false};
            std::exception_ptr exception;
            PythonThreadStateManager* manager;
            ThreadStateInfo* threadInfo;
        };
        
        APCContext context;
        context.func = &func;
        context.manager = this;
        context.threadInfo = targetThread;
        
        auto apcFunc = [](ULONG_PTR param) -> void {
            auto ctx = reinterpret_cast<APCContext*>(param);
            
            // Ensure correct thread state
            ctx->manager->EnsureThreadState(ctx->threadInfo);
            
            try {
                (*ctx->func)();
            } catch (...) {
                ctx->exception = std::current_exception();
            }
            ctx->completed = true;
        };
        
        if (!QueueUserAPC(apcFunc, targetThread->threadHandle, 
                         reinterpret_cast<ULONG_PTR>(&context))) {
            DWORD error = GetLastError();
            std::cerr << "QueueUserAPC failed with error: " << error << std::endl;
            return false;
        }
        
        // Wait for completion with timeout
        auto start = std::chrono::steady_clock::now();
        while (!context.completed) {
            auto elapsed = std::chrono::steady_clock::now() - start;
            if (elapsed > std::chrono::seconds(30)) {
                std::cerr << "Timeout waiting for cross-thread execution" << std::endl;
                return false;
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
        
        if (context.exception) {
            std::rethrow_exception(context.exception);
        }
        
        return true;
    }
    
    void ClearThreadState(ThreadStateInfo* info) {
        if (!info || !info->pyThreadState || !info->isActive) {
            return;
        }
        
        try {
            // Clear the thread state
            if (m_api.PyThreadState_Clear) {
                m_api.PyThreadState_Clear(info->pyThreadState);
            }
            
            // Delete if not main thread
            if (!info->isMainThread && m_api.PyThreadState_Delete) {
                m_api.PyThreadState_Delete(info->pyThreadState);
            }
        } catch (...) {
            std::cerr << "Exception while clearing thread state" << std::endl;
        }
        
        info->isActive = false;
        info->pyThreadState = nullptr;
    }
    
    void GetThreadName(std::string& name) {
        name.clear();
        
        // Windows 10+ API for getting thread description
        typedef HRESULT (WINAPI *GetThreadDescriptionFunc)(HANDLE, PWSTR*);
        
        static GetThreadDescriptionFunc getThreadDescription = nullptr;
        static bool initialized = false;
        
        if (!initialized) {
            HMODULE kernel32 = GetModuleHandleW(L"kernel32.dll");
            if (kernel32) {
                getThreadDescription = (GetThreadDescriptionFunc)GetProcAddress(
                    kernel32, "GetThreadDescription");
            }
            initialized = true;
        }
        
        if (getThreadDescription) {
            PWSTR threadName = nullptr;
            HRESULT hr = getThreadDescription(GetCurrentThread(), &threadName);
            
            if (SUCCEEDED(hr) && threadName) {
                // Convert wide string to narrow
                int size = WideCharToMultiByte(CP_UTF8, 0, threadName, -1, 
                                              nullptr, 0, nullptr, nullptr);
                if (size > 0) {
                    name.resize(size - 1);
                    WideCharToMultiByte(CP_UTF8, 0, threadName, -1, 
                                      &name[0], size, nullptr, nullptr);
                }
                LocalFree(threadName);
            }
        }
        
        // Fallback: use thread ID
        if (name.empty()) {
            std::stringstream ss;
            ss << "Thread-" << GetCurrentThreadId();
            name = ss.str();
        }
    }
    
    // Process tasks queued for main thread
    void ProcessMainThreadTasks() {
        std::unique_lock<std::mutex> lock(m_taskMutex);
        
        while (!m_taskQueue.empty()) {
            auto task = std::move(m_taskQueue.front());
            m_taskQueue.pop();
            
            lock.unlock();
            
            try {
                task.task();
                task.promise.set_value(true);
            } catch (...) {
                task.promise.set_value(false);
            }
            
            lock.lock();
        }
    }
};

// Global instance for thread state management
inline PythonThreadStateManager& GetGlobalThreadStateManager() {
    static PythonThreadStateManager instance;
    return instance;
}
