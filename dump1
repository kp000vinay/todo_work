// OutputSubscription.h - Subscription-based error and stdout capture
#pragma once

#include <string>
#include <functional>
#include <memory>
#include <vector>
#include <stack>
#include <mutex>
#include <thread>
#include <sstream>
#include <atomic>

// Output types
enum class OutputType {
    Stdout,
    Stderr,
    Error,
    Info
};

// Output message
struct OutputMessage {
    OutputType type;
    std::string content;
    std::chrono::system_clock::time_point timestamp;
    std::thread::id threadId;
    size_t contextDepth;  // Nesting level
};

// Subscriber interface
class IOutputSubscriber {
public:
    virtual ~IOutputSubscriber() = default;
    virtual void OnOutput(const OutputMessage& message) = 0;
};

// Forward declarations
class OutputSubscriptionManager;
class OutputSubscription;

// RAII Subscription handle
class OutputSubscription {
private:
    std::shared_ptr<OutputSubscriptionManager> m_manager;
    std::shared_ptr<IOutputSubscriber> m_subscriber;
    size_t m_subscriptionId;
    size_t m_contextDepth;
    bool m_active;
    
public:
    OutputSubscription(std::shared_ptr<OutputSubscriptionManager> manager,
                      std::shared_ptr<IOutputSubscriber> subscriber,
                      size_t id,
                      size_t depth);
    
    ~OutputSubscription();
    
    // Disable copy
    OutputSubscription(const OutputSubscription&) = delete;
    OutputSubscription& operator=(const OutputSubscription&) = delete;
    
    // Enable move
    OutputSubscription(OutputSubscription&& other) noexcept;
    OutputSubscription& operator=(OutputSubscription&& other) noexcept;
    
    void Deactivate();
    bool IsActive() const { return m_active; }
    size_t GetDepth() const { return m_contextDepth; }
};

// Subscription manager
class OutputSubscriptionManager : public std::enable_shared_from_this<OutputSubscriptionManager> {
private:
    struct SubscriptionContext {
        std::shared_ptr<IOutputSubscriber> subscriber;
        size_t id;
        size_t depth;
        std::thread::id threadId;
    };
    
    std::vector<SubscriptionContext> m_subscriptions;
    std::atomic<size_t> m_nextId{1};
    std::mutex m_mutex;
    
    // Thread-local context stack for tracking nesting
    static thread_local std::stack<size_t> t_contextStack;
    
public:
    OutputSubscriptionManager() = default;
    
    // Subscribe to outputs - returns RAII handle
    [[nodiscard]] OutputSubscription Subscribe(std::shared_ptr<IOutputSubscriber> subscriber);
    
    // Publish output to appropriate subscribers
    void PublishOutput(OutputType type, const std::string& content);
    
    // Get current context depth
    size_t GetCurrentDepth() const;
    
private:
    friend class OutputSubscription;
    
    size_t AddSubscription(std::shared_ptr<IOutputSubscriber> subscriber);
    void RemoveSubscription(size_t id);
    void PushContext(size_t depth);
    void PopContext();
};

// Thread-local storage definition
thread_local std::stack<size_t> OutputSubscriptionManager::t_contextStack;

// Built-in subscriber implementations

// Simple callback subscriber
class CallbackSubscriber : public IOutputSubscriber {
private:
    std::function<void(const OutputMessage&)> m_callback;
    
public:
    explicit CallbackSubscriber(std::function<void(const OutputMessage&)> callback)
        : m_callback(std::move(callback)) {}
    
    void OnOutput(const OutputMessage& message) override {
        if (m_callback) m_callback(message);
    }
};

// Filtering subscriber
class FilteringSubscriber : public IOutputSubscriber {
private:
    std::shared_ptr<IOutputSubscriber> m_inner;
    std::function<bool(const OutputMessage&)> m_filter;
    
public:
    FilteringSubscriber(std::shared_ptr<IOutputSubscriber> inner,
                       std::function<bool(const OutputMessage&)> filter)
        : m_inner(std::move(inner)), m_filter(std::move(filter)) {}
    
    void OnOutput(const OutputMessage& message) override {
        if (m_filter(message) && m_inner) {
            m_inner->OnOutput(message);
        }
    }
};

// Buffering subscriber
class BufferingSubscriber : public IOutputSubscriber {
private:
    std::vector<OutputMessage> m_buffer;
    std::mutex m_mutex;
    size_t m_maxSize;
    
public:
    explicit BufferingSubscriber(size_t maxSize = 1000) : m_maxSize(maxSize) {}
    
    void OnOutput(const OutputMessage& message) override {
        std::lock_guard<std::mutex> lock(m_mutex);
        if (m_buffer.size() >= m_maxSize) {
            m_buffer.erase(m_buffer.begin());
        }
        m_buffer.push_back(message);
    }
    
    std::vector<OutputMessage> GetMessages() const {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_buffer;
    }
    
    void Clear() {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_buffer.clear();
    }
};

// Stream subscriber (writes to ostream)
class StreamSubscriber : public IOutputSubscriber {
private:
    std::ostream& m_stream;
    bool m_includeMetadata;
    std::mutex m_mutex;
    
public:
    explicit StreamSubscriber(std::ostream& stream, bool includeMetadata = false)
        : m_stream(stream), m_includeMetadata(includeMetadata) {}
    
    void OnOutput(const OutputMessage& message) override {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_includeMetadata) {
            auto time_t = std::chrono::system_clock::to_time_t(message.timestamp);
            m_stream << "[" << std::put_time(std::localtime(&time_t), "%H:%M:%S") << "] ";
            
            switch (message.type) {
                case OutputType::Stdout: m_stream << "[STDOUT] "; break;
                case OutputType::Stderr: m_stream << "[STDERR] "; break;
                case OutputType::Error:  m_stream << "[ERROR]  "; break;
                case OutputType::Info:   m_stream << "[INFO]   "; break;
            }
            
            m_stream << "[D:" << message.contextDepth << "] ";
        }
        
        m_stream << message.content;
        if (!message.content.empty() && message.content.back() != '\n') {
            m_stream << std::endl;
        }
        m_stream.flush();
    }
};

// Implementation

OutputSubscription::OutputSubscription(std::shared_ptr<OutputSubscriptionManager> manager,
                                     std::shared_ptr<IOutputSubscriber> subscriber,
                                     size_t id,
                                     size_t depth)
    : m_manager(std::move(manager))
    , m_subscriber(std::move(subscriber))
    , m_subscriptionId(id)
    , m_contextDepth(depth)
    , m_active(true) {
    
    if (m_manager) {
        m_manager->PushContext(depth);
    }
}

OutputSubscription::~OutputSubscription() {
    Deactivate();
}

OutputSubscription::OutputSubscription(OutputSubscription&& other) noexcept
    : m_manager(std::move(other.m_manager))
    , m_subscriber(std::move(other.m_subscriber))
    , m_subscriptionId(other.m_subscriptionId)
    , m_contextDepth(other.m_contextDepth)
    , m_active(other.m_active) {
    other.m_active = false;
}

OutputSubscription& OutputSubscription::operator=(OutputSubscription&& other) noexcept {
    if (this != &other) {
        Deactivate();
        m_manager = std::move(other.m_manager);
        m_subscriber = std::move(other.m_subscriber);
        m_subscriptionId = other.m_subscriptionId;
        m_contextDepth = other.m_contextDepth;
        m_active = other.m_active;
        other.m_active = false;
    }
    return *this;
}

void OutputSubscription::Deactivate() {
    if (m_active && m_manager) {
        m_manager->RemoveSubscription(m_subscriptionId);
        m_manager->PopContext();
        m_active = false;
    }
}

OutputSubscription OutputSubscriptionManager::Subscribe(std::shared_ptr<IOutputSubscriber> subscriber) {
    size_t id = AddSubscription(subscriber);
    size_t depth = GetCurrentDepth() + 1;
    return OutputSubscription(shared_from_this(), subscriber, id, depth);
}

size_t OutputSubscriptionManager::AddSubscription(std::shared_ptr<IOutputSubscriber> subscriber) {
    std::lock_guard<std::mutex> lock(m_mutex);
    size_t id = m_nextId++;
    size_t depth = GetCurrentDepth() + 1;
    
    m_subscriptions.push_back({subscriber, id, depth, std::this_thread::get_id()});
    return id;
}

void OutputSubscriptionManager::RemoveSubscription(size_t id) {
    std::lock_guard<std::mutex> lock(m_mutex);
    m_subscriptions.erase(
        std::remove_if(m_subscriptions.begin(), m_subscriptions.end(),
                      [id](const SubscriptionContext& ctx) { return ctx.id == id; }),
        m_subscriptions.end()
    );
}

void OutputSubscriptionManager::PublishOutput(OutputType type, const std::string& content) {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    OutputMessage message{
        type,
        content,
        std::chrono::system_clock::now(),
        std::this_thread::get_id(),
        GetCurrentDepth()
    };
    
    // Find the deepest subscription that should receive this message
    size_t maxDepth = 0;
    std::shared_ptr<IOutputSubscriber> targetSubscriber;
    
    for (const auto& ctx : m_subscriptions) {
        // Only consider subscriptions in the current thread
        if (ctx.threadId != std::this_thread::get_id()) continue;
        
        // Only consider subscriptions at or above current depth
        if (ctx.depth <= message.contextDepth && ctx.depth > maxDepth) {
            maxDepth = ctx.depth;
            targetSubscriber = ctx.subscriber;
        }
    }
    
    // Deliver to the deepest matching subscription only
    if (targetSubscriber) {
        targetSubscriber->OnOutput(message);
    }
}

size_t OutputSubscriptionManager::GetCurrentDepth() const {
    return t_contextStack.empty() ? 0 : t_contextStack.top();
}

void OutputSubscriptionManager::PushContext(size_t depth) {
    t_contextStack.push(depth);
}

void OutputSubscriptionManager::PopContext() {
    if (!t_contextStack.empty()) {
        t_contextStack.pop();
    }
}

// Convenience functions for creating subscriptions

template<typename Func>
OutputSubscription SubscribeCallback(std::shared_ptr<OutputSubscriptionManager> manager,
                                   Func&& callback) {
    return manager->Subscribe(std::make_shared<CallbackSubscriber>(std::forward<Func>(callback)));
}

OutputSubscription SubscribeToStream(std::shared_ptr<OutputSubscriptionManager> manager,
                                   std::ostream& stream,
                                   bool includeMetadata = false) {
    return manager->Subscribe(std::make_shared<StreamSubscriber>(stream, includeMetadata));
}

OutputSubscription SubscribeWithFilter(std::shared_ptr<OutputSubscriptionManager> manager,
                                     std::shared_ptr<IOutputSubscriber> inner,
                                     std::function<bool(const OutputMessage&)> filter) {
    return manager->Subscribe(std::make_shared<FilteringSubscriber>(inner, filter));
}

// Usage example with nested contexts
class SubscriptionExample {
public:
    static void Demonstrate() {
        auto manager = std::make_shared<OutputSubscriptionManager>();
        
        // Parent context - captures all output
        std::stringstream parentStream;
        auto parentSub = SubscribeToStream(manager, parentStream, true);
        
        manager->PublishOutput(OutputType::Info, "Parent level message");
        
        {
            // Child context - captures only its own output
            std::stringstream childStream;
            auto childSub = SubscribeToStream(manager, childStream, true);
            
            manager->PublishOutput(OutputType::Info, "Child level message");
            
            {
                // Grandchild context
                auto grandchildSub = SubscribeCallback(manager,
                    [](const OutputMessage& msg) {
                        std::cout << "Grandchild sees: " << msg.content << std::endl;
                    });
                
                manager->PublishOutput(OutputType::Error, "Grandchild error");
                // This error only goes to grandchild, not to child or parent
            }
            
            manager->PublishOutput(OutputType::Info, "Back in child context");
        }
        
        manager->PublishOutput(OutputType::Info, "Back in parent context");
        
        std::cout << "Parent captured:\n" << parentStream.str() << std::endl;
    }
};

//===================================

// PythonBridgeWithSubscription.h - Integration of subscription system with Python bridge
#pragma once

#include "IPythonEnvironment.h"
#include "OutputSubscription.h"
#include <Python.h>

// Extended bridge interface with subscription support
class IPythonBridgeWithSubscription : public IPythonBridge {
public:
    virtual void SetOutputManager(std::shared_ptr<OutputSubscriptionManager> manager) = 0;
    virtual std::shared_ptr<OutputSubscriptionManager> GetOutputManager() = 0;
};

// Python stdout/stderr capture implementation
class PythonOutputCapture {
private:
    PyObject* m_originalStdout = nullptr;
    PyObject* m_originalStderr = nullptr;
    PyObject* m_captureObj = nullptr;
    std::weak_ptr<OutputSubscriptionManager> m_manager;
    
    // Python object that captures output
    static PyObject* CreateCaptureObject(OutputSubscriptionManager* manager, OutputType type);
    
public:
    PythonOutputCapture() = default;
    ~PythonOutputCapture() { Restore(); }
    
    void Install(std::shared_ptr<OutputSubscriptionManager> manager);
    void Restore();
};

// Extended Python bridge with subscription support
class PythonBridgeWithSubscription : public IPythonBridgeWithSubscription {
private:
    // ... (previous PythonBridge members) ...
    std::shared_ptr<OutputSubscriptionManager> m_outputManager;
    PythonOutputCapture m_outputCapture;
    
    // Override MakeResult to capture errors
    PyResult MakeResultWithErrorCapture(PyObject* obj, bool stealRef = false) {
        PyResult result;
        
        if (PyErr_Occurred()) {
            result.success = false;
            result.error = GetPythonError();
            result.objectId = INVALID_OBJECT_ID;
            
            // Publish error to subscription system
            if (m_outputManager) {
                m_outputManager->PublishOutput(OutputType::Error, result.error);
            }
            
            if (stealRef && obj) Py_DECREF(obj);
            return result;
        }
        
        // ... (rest of MakeResult implementation) ...
        return result;
    }
    
public:
    PythonBridgeWithSubscription() {
        // Initialize as before
        m_outputManager = std::make_shared<OutputSubscriptionManager>();
    }
    
    void SetOutputManager(std::shared_ptr<OutputSubscriptionManager> manager) override {
        m_outputManager = manager;
        if (manager) {
            m_outputCapture.Install(manager);
        } else {
            m_outputCapture.Restore();
        }
    }
    
    std::shared_ptr<OutputSubscriptionManager> GetOutputManager() override {
        return m_outputManager;
    }
    
    // All methods now use MakeResultWithErrorCapture instead of MakeResult
    PyResult ExecuteString(const std::string& code) override {
        PyObject* result = PyRun_String(code.c_str(), Py_file_input, 
                                        m_globalDict, m_localDict);
        return MakeResultWithErrorCapture(result, true);
    }
    
    // ... (implement other methods similarly) ...
};

// Python capture object implementation (in .cpp file)
static PyTypeObject CaptureType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "pythonbridge.OutputCapture",  // tp_name
    sizeof(PyObject),              // tp_basicsize
    0,                            // tp_itemsize
    // ... (other fields) ...
};

// RAII helper for scoped output capture
class ScopedPythonOperation {
private:
    OutputSubscription m_subscription;
    std::vector<OutputMessage> m_capturedOutput;
    
public:
    ScopedPythonOperation(IPythonBridgeWithSubscription* bridge,
                         bool captureStdout = true,
                         bool captureStderr = true,
                         bool captureErrors = true)
        : m_subscription(bridge->GetOutputManager()->Subscribe(
            std::make_shared<CallbackSubscriber>(
                [this, captureStdout, captureStderr, captureErrors](const OutputMessage& msg) {
                    bool shouldCapture = false;
                    switch (msg.type) {
                        case OutputType::Stdout: shouldCapture = captureStdout; break;
                        case OutputType::Stderr: shouldCapture = captureStderr; break;
                        case OutputType::Error:  shouldCapture = captureErrors; break;
                        default: shouldCapture = true;
                    }
                    if (shouldCapture) {
                        m_capturedOutput.push_back(msg);
                    }
                }
            )
        )) {}
    
    const std::vector<OutputMessage>& GetCapturedOutput() const {
        return m_capturedOutput;
    }
    
    std::string GetCombinedOutput() const {
        std::stringstream ss;
        for (const auto& msg : m_capturedOutput) {
            ss << msg.content;
        }
        return ss.str();
    }
    
    std::vector<std::string> GetErrors() const {
        std::vector<std::string> errors;
        for (const auto& msg : m_capturedOutput) {
            if (msg.type == OutputType::Error || msg.type == OutputType::Stderr) {
                errors.push_back(msg.content);
            }
        }
        return errors;
    }
    
    bool HasErrors() const {
        return std::any_of(m_capturedOutput.begin(), m_capturedOutput.end(),
                          [](const OutputMessage& msg) {
                              return msg.type == OutputType::Error || 
                                     msg.type == OutputType::Stderr;
                          });
    }
};

// Usage examples
class PythonSubscriptionExamples {
public:
    static void BasicExample(IPythonBridgeWithSubscription* bridge) {
        // Example 1: Capture output from a specific operation
        {
            ScopedPythonOperation op(bridge);
            
            bridge->ExecuteString("print('Hello from Python!')");
            bridge->ExecuteString("import sys; sys.stderr.write('Warning!\\n')");
            bridge->ExecuteString("1 / 0");  // Will generate error
            
            std::cout << "Captured output:\n" << op.GetCombinedOutput() << std::endl;
            
            if (op.HasErrors()) {
                std::cout << "Errors occurred:\n";
                for (const auto& error : op.GetErrors()) {
                    std::cout << "  - " << error << std::endl;
                }
            }
        }
    }
    
    static void NestedContextExample(IPythonBridgeWithSubscription* bridge) {
        auto manager = bridge->GetOutputManager();
        
        // Parent context - log everything to file
        std::ofstream logFile("python_operations.log");
        auto parentSub = SubscribeToStream(manager, logFile, true);
        
        bridge->ExecuteString("print('Starting operations...')");
        
        {
            // Child context - only capture errors
            auto errorBuffer = std::make_shared<BufferingSubscriber>();
            auto errorSub = SubscribeWithFilter(manager, errorBuffer,
                [](const OutputMessage& msg) {
                    return msg.type == OutputType::Error || msg.type == OutputType::Stderr;
                });
            
            bridge->ExecuteString("print('This goes to parent only')");
            bridge->ExecuteString("raise ValueError('This error goes to child')");
            
            // Process errors in child context
            for (const auto& msg : errorBuffer->GetMessages()) {
                std::cout << "Child caught error: " << msg.content << std::endl;
            }
        }
        
        bridge->ExecuteString("print('Back in parent context')");
    }
    
    static void FilteredSubscriptionExample(IPythonBridgeWithSubscription* bridge) {
        auto manager = bridge->GetOutputManager();
        
        // Subscribe only to warnings
        auto warningSub = SubscribeCallback(manager,
            [](const OutputMessage& msg) {
                if (msg.content.find("Warning") != std::string::npos ||
                    msg.content.find("warning") != std::string::npos) {
                    std::cout << "[WARNING DETECTED] " << msg.content << std::endl;
                }
            });
        
        bridge->ExecuteString(R"(
            import warnings
            warnings.warn("This is a test warning")
            print("This is not a warning")
            warnings.warn("Another warning here")
        )");
    }
    
    static void ThreadedExample(IPythonBridgeWithSubscription* bridge) {
        auto manager = bridge->GetOutputManager();
        
        std::thread t1([bridge, manager]() {
            auto threadSub = SubscribeCallback(manager,
                [](const OutputMessage& msg) {
                    std::cout << "[Thread 1] " << msg.content << std::endl;
                });
            
            bridge->ExecuteString("print('Message from thread 1')");
        });
        
        std::thread t2([bridge, manager]() {
            auto threadSub = SubscribeCallback(manager,
                [](const OutputMessage& msg) {
                    std::cout << "[Thread 2] " << msg.content << std::endl;
                });
            
            bridge->ExecuteString("print('Message from thread 2')");
        });
        
        t1.join();
        t2.join();
    }
};

// Utility class for testing and debugging
class PythonOperationRecorder {
private:
    struct Operation {
        std::string code;
        std::vector<OutputMessage> output;
        bool success;
        std::chrono::system_clock::time_point timestamp;
    };
    
    IPythonBridgeWithSubscription* m_bridge;
    std::vector<Operation> m_operations;
    
public:
    explicit PythonOperationRecorder(IPythonBridgeWithSubscription* bridge)
        : m_bridge(bridge) {}
    
    PyResult ExecuteAndRecord(const std::string& code) {
        Operation op;
        op.code = code;
        op.timestamp = std::chrono::system_clock::now();
        
        ScopedPythonOperation scopedOp(m_bridge);
        auto result = m_bridge->ExecuteString(code);
        
        op.output = scopedOp.GetCapturedOutput();
        op.success = result.success;
        
        m_operations.push_back(std::move(op));
        return result;
    }
    
    void GenerateReport(std::ostream& out) const {
        out << "Python Operation Report\n";
        out << "======================\n\n";
        
        for (size_t i = 0; i < m_operations.size(); ++i) {
            const auto& op = m_operations[i];
            
            auto time_t = std::chrono::system_clock::to_time_t(op.timestamp);
            out << "Operation #" << (i + 1) << " at " 
                << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S") << "\n";
            out << "Code:\n" << op.code << "\n";
            out << "Success: " << (op.success ? "Yes" : "No") << "\n";
            
            if (!op.output.empty()) {
                out << "Output:\n";
                for (const auto& msg : op.output) {
                    switch (msg.type) {
                        case OutputType::Stdout: out << "  [STDOUT] "; break;
                        case OutputType::Stderr: out << "  [STDERR] "; break;
                        case OutputType::Error:  out << "  [ERROR]  "; break;
                        case OutputType::Info:   out << "  [INFO]   "; break;
                    }
                    out << msg.content;
                    if (!msg.content.empty() && msg.content.back() != '\n') {
                        out << "\n";
                    }
                }
            }
            
            out << "\n";
        }
    }
};

//=========================
// PythonOutputCapture.cpp - Implementation of Python stdout/stderr capture
#include <Python.h>
#include "OutputSubscription.h"

// Python object that captures write() calls
typedef struct {
    PyObject_HEAD
    OutputSubscriptionManager* manager;
    OutputType outputType;
} CaptureObject;

// write() method for capture object
static PyObject* Capture_write(CaptureObject* self, PyObject* args) {
    const char* str;
    if (!PyArg_ParseTuple(args, "s", &str)) {
        return NULL;
    }
    
    if (self->manager && str) {
        self->manager->PublishOutput(self->outputType, std::string(str));
    }
    
    // Return number of bytes written (required by Python)
    return PyLong_FromSsize_t(strlen(str));
}

// flush() method (required for file-like objects)
static PyObject* Capture_flush(CaptureObject* self, PyObject* args) {
    Py_RETURN_NONE;
}

// isatty() method (return False)
static PyObject* Capture_isatty(CaptureObject* self, PyObject* args) {
    Py_RETURN_FALSE;
}

static PyMethodDef Capture_methods[] = {
    {"write", (PyCFunction)Capture_write, METH_VARARGS, "Write string to output manager"},
    {"flush", (PyCFunction)Capture_flush, METH_NOARGS, "Flush (no-op)"},
    {"isatty", (PyCFunction)Capture_isatty, METH_NOARGS, "Return False"},
    {NULL}  // Sentinel
};

static PyTypeObject CaptureType = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "pythonbridge.OutputCapture",
    .tp_basicsize = sizeof(CaptureObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_doc = "Output capture object",
    .tp_methods = Capture_methods,
    .tp_new = PyType_GenericNew,
};

// Create a new capture object
static PyObject* CreateCaptureObject(OutputSubscriptionManager* manager, OutputType type) {
    if (PyType_Ready(&CaptureType) < 0) {
        return nullptr;
    }
    
    CaptureObject* capture = PyObject_New(CaptureObject, &CaptureType);
    if (capture) {
        capture->manager = manager;
        capture->outputType = type;
    }
    
    return (PyObject*)capture;
}

// Implementation of PythonOutputCapture class
class PythonOutputCapture {
private:
    PyObject* m_originalStdout = nullptr;
    PyObject* m_originalStderr = nullptr;
    PyObject* m_stdoutCapture = nullptr;
    PyObject* m_stderrCapture = nullptr;
    bool m_installed = false;
    
public:
    ~PythonOutputCapture() {
        Restore();
    }
    
    void Install(OutputSubscriptionManager* manager) {
        if (m_installed || !manager) return;
        
        // Save original stdout/stderr
        m_originalStdout = PySys_GetObject("stdout");
        m_originalStderr = PySys_GetObject("stderr");
        
        if (m_originalStdout) Py_INCREF(m_originalStdout);
        if (m_originalStderr) Py_INCREF(m_originalStderr);
        
        // Create capture objects
        m_stdoutCapture = CreateCaptureObject(manager, OutputType::Stdout);
        m_stderrCapture = CreateCaptureObject(manager, OutputType::Stderr);
        
        if (m_stdoutCapture && m_stderrCapture) {
            // Replace sys.stdout and sys.stderr
            PySys_SetObject("stdout", m_stdoutCapture);
            PySys_SetObject("stderr", m_stderrCapture);
            m_installed = true;
        } else {
            // Cleanup on failure
            Py_XDECREF(m_stdoutCapture);
            Py_XDECREF(m_stderrCapture);
            m_stdoutCapture = nullptr;
            m_stderrCapture = nullptr;
        }
    }
    
    void Restore() {
        if (!m_installed) return;
        
        // Restore original stdout/stderr
        if (m_originalStdout) {
            PySys_SetObject("stdout", m_originalStdout);
            Py_DECREF(m_originalStdout);
            m_originalStdout = nullptr;
        }
        
        if (m_originalStderr) {
            PySys_SetObject("stderr", m_originalStderr);
            Py_DECREF(m_originalStderr);
            m_originalStderr = nullptr;
        }
        
        // Cleanup capture objects
        Py_XDECREF(m_stdoutCapture);
        Py_XDECREF(m_stderrCapture);
        m_stdoutCapture = nullptr;
        m_stderrCapture = nullptr;
        
        m_installed = false;
    }
    
    bool IsInstalled() const {
        return m_installed;
    }
};

// Advanced subscription patterns
namespace SubscriptionPatterns {
    
    // Pattern 1: Operation with timeout and output capture
    template<typename Func>
    class TimedOperation {
    private:
        IPythonBridgeWithSubscription* m_bridge;
        std::chrono::milliseconds m_timeout;
        std::atomic<bool> m_completed{false};
        std::vector<OutputMessage> m_output;
        
    public:
        TimedOperation(IPythonBridgeWithSubscription* bridge, std::chrono::milliseconds timeout)
            : m_bridge(bridge), m_timeout(timeout) {}
        
        bool Execute(Func&& operation) {
            auto subscription = m_bridge->GetOutputManager()->Subscribe(
                std::make_shared<CallbackSubscriber>([this](const OutputMessage& msg) {
                    m_output.push_back(msg);
                })
            );
            
            std::thread worker([this, &operation]() {
                operation(m_bridge);
                m_completed = true;
            });
            
            auto start = std::chrono::steady_clock::now();
            while (!m_completed && 
                   std::chrono::steady_clock::now() - start < m_timeout) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
            }
            
            if (!m_completed) {
                // Timeout - attempt to interrupt Python
                PyGILState_STATE gstate = PyGILState_Ensure();
                PyErr_SetString(PyExc_KeyboardInterrupt, "Operation timed out");
                PyGILState_Release(gstate);
            }
            
            worker.join();
            return m_completed;
        }
        
        const std::vector<OutputMessage>& GetOutput() const { return m_output; }
    };
    
    // Pattern 2: Hierarchical error collection
    class ErrorCollector {
    private:
        struct ErrorContext {
            std::string name;
            std::vector<std::string> errors;
            std::vector<std::unique_ptr<ErrorContext>> children;
        };
        
        std::unique_ptr<ErrorContext> m_root;
        ErrorContext* m_current;
        IPythonBridgeWithSubscription* m_bridge;
        
    public:
        ErrorCollector(IPythonBridgeWithSubscription* bridge, const std::string& rootName)
            : m_bridge(bridge) {
            m_root = std::make_unique<ErrorContext>();
            m_root->name = rootName;
            m_current = m_root.get();
        }
        
        class Scope {
        private:
            ErrorCollector* m_collector;
            ErrorContext* m_previousContext;
            OutputSubscription m_subscription;
            
        public:
            Scope(ErrorCollector* collector, const std::string& name)
                : m_collector(collector)
                , m_previousContext(collector->m_current)
                , m_subscription(collector->m_bridge->GetOutputManager()->Subscribe(
                    std::make_shared<CallbackSubscriber>([this](const OutputMessage& msg) {
                        if (msg.type == OutputType::Error || msg.type == OutputType::Stderr) {
                            m_collector->m_current->errors.push_back(msg.content);
                        }
                    })
                )) {
                
                auto newContext = std::make_unique<ErrorContext>();
                newContext->name = name;
                m_collector->m_current->children.push_back(std::move(newContext));
                m_collector->m_current = m_collector->m_current->children.back().get();
            }
            
            ~Scope() {
                m_collector->m_current = m_previousContext;
            }
        };
        
        [[nodiscard]] Scope CreateScope(const std::string& name) {
            return Scope(this, name);
        }
        
        void PrintReport(std::ostream& out, const ErrorContext* ctx = nullptr, int indent = 0) const {
            if (!ctx) ctx = m_root.get();
            
            std::string indentStr(indent * 2, ' ');
            out << indentStr << ctx->name << ":\n";
            
            if (!ctx->errors.empty()) {
                for (const auto& error : ctx->errors) {
                    out << indentStr << "  ERROR: " << error;
                    if (!error.empty() && error.back() != '\n') out << '\n';
                }
            } else {
                out << indentStr << "  (no errors)\n";
            }
            
            for (const auto& child : ctx->children) {
                PrintReport(out, child.get(), indent + 1);
            }
        }
    };
    
    // Pattern 3: Conditional output routing
    class ConditionalRouter {
    private:
        struct Route {
            std::function<bool(const OutputMessage&)> condition;
            std::shared_ptr<IOutputSubscriber> subscriber;
        };
        
        std::vector<Route> m_routes;
        std::shared_ptr<IOutputSubscriber> m_defaultSubscriber;
        
    public:
        void AddRoute(std::function<bool(const OutputMessage&)> condition,
                     std::shared_ptr<IOutputSubscriber> subscriber) {
            m_routes.push_back({condition, subscriber});
        }
        
        void SetDefault(std::shared_ptr<IOutputSubscriber> subscriber) {
            m_defaultSubscriber = subscriber;
        }
        
        std::shared_ptr<IOutputSubscriber> CreateRouter() {
            return std::make_shared<CallbackSubscriber>([this](const OutputMessage& msg) {
                for (const auto& route : m_routes) {
                    if (route.condition(msg)) {
                        route.subscriber->OnOutput(msg);
                        return;
                    }
                }
                if (m_defaultSubscriber) {
                    m_defaultSubscriber->OnOutput(msg);
                }
            });
        }
    };
}

// Complete usage example
void DemonstrateSubscriptionSystem() {
    // Initialize Python environment and bridge
    auto manager = CreatePythonEnvironmentManager();
    auto env = manager->GetEnvironment("C:\\Python\\envs\\test");
    env->Initialize();
    
    auto bridge = dynamic_cast<IPythonBridgeWithSubscription*>(env->GetBridge());
    if (!bridge) return;
    
    // Example 1: Error collection with hierarchy
    {
        SubscriptionPatterns::ErrorCollector collector(bridge, "Data Processing Pipeline");
        
        {
            auto scope1 = collector.CreateScope("Data Loading");
            bridge->ExecuteString("import pandas as pd");
            bridge->ExecuteString("df = pd.read_csv('nonexistent.csv')");  // Error
        }
        
        {
            auto scope2 = collector.CreateScope("Data Transformation");
            bridge->ExecuteString("df = pd.DataFrame({'A': [1,2,3], 'B': [4,5,6]})");
            
            {
                auto scope3 = collector.CreateScope("Column Operations");
                bridge->ExecuteString("df['C'] = df['A'] / df['B']");
                bridge->ExecuteString("df['D'] = df['NonExistent']");  // Error
            }
        }
        
        std::cout << "\nError Report:\n";
        collector.PrintReport(std::cout);
    }
    
    // Example 2: Conditional routing
    {
        SubscriptionPatterns::ConditionalRouter router;
        
        // Route errors to error log
        std::ofstream errorLog("errors.log");
        router.AddRoute(
            [](const OutputMessage& msg) { 
                return msg.type == OutputType::Error || msg.type == OutputType::Stderr; 
            },
            std::make_shared<StreamSubscriber>(errorLog, true)
        );
        
        // Route print statements to console
        router.AddRoute(
            [](const OutputMessage& msg) { 
                return msg.type == OutputType::Stdout; 
            },
            std::make_shared<StreamSubscriber>(std::cout, false)
        );
        
        // Route warnings to a buffer
        auto warningBuffer = std::make_shared<BufferingSubscriber>();
        router.AddRoute(
            [](const OutputMessage& msg) {
                return msg.content.find("Warning") != std::string::npos;
            },
            warningBuffer
        );
        
        auto subscription = bridge->GetOutputManager()->Subscribe(router.CreateRouter());
        
        // Execute various operations
        bridge->ExecuteString("print('Normal output')");
        bridge->ExecuteString("import warnings; warnings.warn('Test warning')");
        bridge->ExecuteString("1/0");  // Error
    }
}

//=======================
// SimpleSubscriptionExample.cpp - Demonstrates nested subscription behavior

#include <iostream>
#include <sstream>
#include <memory>

// Simple example demonstrating the core concept
void DemonstrateNestedSubscriptions() {
    // Create the output manager
    auto manager = std::make_shared<OutputSubscriptionManager>();
    
    // Simulate a Python bridge
    auto simulateOperation = [&manager](const std::string& operation, bool causesError) {
        manager->PublishOutput(OutputType::Info, "Executing: " + operation + "\n");
        if (causesError) {
            manager->PublishOutput(OutputType::Error, "Error in " + operation + "\n");
        } else {
            manager->PublishOutput(OutputType::Stdout, "Success: " + operation + "\n");
        }
    };
    
    std::cout << "=== Nested Subscription Example ===" << std::endl;
    std::cout << "Parent subscription sees its own operations and operations outside any child context.\n";
    std::cout << "Child subscriptions see ONLY their own operations.\n\n";
    
    // Parent context
    std::stringstream parentOutput;
    auto parentSub = SubscribeCallback(manager, 
        [&parentOutput](const OutputMessage& msg) {
            parentOutput << "[PARENT] " << msg.content;
        });
    
    simulateOperation("Parent Operation 1", false);
    
    {
        // Child context 1
        std::stringstream child1Output;
        auto child1Sub = SubscribeCallback(manager,
            [&child1Output](const OutputMessage& msg) {
                child1Output << "[CHILD1] " << msg.content;
            });
        
        simulateOperation("Child1 Operation", true);  // This error goes ONLY to child1
        
        {
            // Grandchild context
            std::stringstream grandchildOutput;
            auto grandchildSub = SubscribeCallback(manager,
                [&grandchildOutput](const OutputMessage& msg) {
                    grandchildOutput << "[GRANDCHILD] " << msg.content;
                });
            
            simulateOperation("Grandchild Operation", true);  // This error goes ONLY to grandchild
            
            std::cout << "Grandchild Output:\n" << grandchildOutput.str() << std::endl;
        }
        
        simulateOperation("Child1 Operation 2", false);
        
        std::cout << "Child1 Output:\n" << child1Output.str() << std::endl;
    }
    
    {
        // Child context 2
        std::stringstream child2Output;
        auto child2Sub = SubscribeCallback(manager,
            [&child2Output](const OutputMessage& msg) {
                child2Output << "[CHILD2] " << msg.content;
            });
        
        simulateOperation("Child2 Operation", true);  // This error goes ONLY to child2
        
        std::cout << "Child2 Output:\n" << child2Output.str() << std::endl;
    }
    
    simulateOperation("Parent Operation 2", false);
    
    std::cout << "Parent Output:\n" << parentOutput.str() << std::endl;
}

// Practical example: Database operations with nested error handling
class DatabaseOperations {
private:
    std::shared_ptr<OutputSubscriptionManager> m_manager;
    IPythonBridgeWithSubscription* m_bridge;
    
public:
    DatabaseOperations(IPythonBridgeWithSubscription* bridge) 
        : m_bridge(bridge), m_manager(bridge->GetOutputManager()) {}
    
    void RunMigrations() {
        // Top-level error handler
        auto migrationErrors = std::make_shared<BufferingSubscriber>();
        auto migrationSub = SubscribeWithFilter(m_manager, migrationErrors,
            [](const OutputMessage& msg) { return msg.type == OutputType::Error; });
        
        std::cout << "Starting database migrations..." << std::endl;
        
        // Migration 1: Create tables
        if (!RunSingleMigration("CreateTables", R"(
            # Create tables migration
            cursor.execute('''CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                name TEXT NOT NULL
            )''')
            print("Tables created successfully")
        )")) {
            std::cout << "CreateTables migration failed!" << std::endl;
        }
        
        // Migration 2: Add indexes (will fail)
        if (!RunSingleMigration("AddIndexes", R"(
            # Add indexes migration
            cursor.execute('CREATE INDEX idx_nonexistent ON nonexistent_table(id)')
            print("Indexes created successfully")
        )")) {
            std::cout << "AddIndexes migration failed!" << std::endl;
        }
        
        // Check overall migration status
        if (!migrationErrors->GetMessages().empty()) {
            std::cout << "\nSome migrations failed. Errors:\n";
            for (const auto& error : migrationErrors->GetMessages()) {
                std::cout << "  - " << error.content;
            }
        } else {
            std::cout << "\nAll migrations completed successfully!" << std::endl;
        }
    }
    
private:
    bool RunSingleMigration(const std::string& name, const std::string& code) {
        // Each migration gets its own error context
        bool success = true;
        
        {
            auto migrationOutput = std::make_shared<BufferingSubscriber>();
            auto migrationSub = m_manager->Subscribe(migrationOutput);
            
            std::cout << "\nRunning migration: " << name << std::endl;
            
            auto result = m_bridge->ExecuteString(code);
            
            // Check for errors in this migration only
            for (const auto& msg : migrationOutput->GetMessages()) {
                if (msg.type == OutputType::Error || msg.type == OutputType::Stderr) {
                    std::cout << "  ERROR in " << name << ": " << msg.content;
                    success = false;
                } else if (msg.type == OutputType::Stdout) {
                    std::cout << "  " << msg.content;
                }
            }
        }
        
        return success;
    }
};

// Example showing operation isolation
void DemonstrateOperationIsolation() {
    auto manager = std::make_shared<OutputSubscriptionManager>();
    
    // Global logger - sees everything at root level
    std::ofstream globalLog("operations.log");
    auto globalSub = SubscribeToStream(manager, globalLog, true);
    
    // Operation A with its own error handling
    {
        std::cout << "\n=== Operation A ===" << std::endl;
        std::vector<std::string> operationAErrors;
        
        auto opASub = SubscribeCallback(manager,
            [&operationAErrors](const OutputMessage& msg) {
                if (msg.type == OutputType::Error) {
                    operationAErrors.push_back(msg.content);
                }
            });
        
        manager->PublishOutput(OutputType::Info, "Starting Operation A");
        manager->PublishOutput(OutputType::Error, "Operation A specific error");
        manager->PublishOutput(OutputType::Info, "Operation A completed");
        
        std::cout << "Operation A errors: " << operationAErrors.size() << std::endl;
    }
    
    // Operation B with its own error handling
    {
        std::cout << "\n=== Operation B ===" << std::endl;
        std::vector<std::string> operationBErrors;
        
        auto opBSub = SubscribeCallback(manager,
            [&operationBErrors](const OutputMessage& msg) {
                if (msg.type == OutputType::Error) {
                    operationBErrors.push_back(msg.content);
                }
            });
        
        manager->PublishOutput(OutputType::Info, "Starting Operation B");
        manager->PublishOutput(OutputType::Info, "Operation B completed successfully");
        
        std::cout << "Operation B errors: " << operationBErrors.size() << std::endl;
    }
    
    // Global operations
    manager->PublishOutput(OutputType::Info, "All operations completed");
    
    std::cout << "\nCheck operations.log for root-level messages only" << std::endl;
}

int main() {
    // Run the demonstrations
    DemonstrateNestedSubscriptions();
    std::cout << "\n" << std::string(50, '=') << "\n" << std::endl;
    DemonstrateOperationIsolation();
    
    return 0;
}

//============================

// PythonEnvironmentImpl.h - Complete implementation
#pragma once

#include "IPythonEnvironment.h"
#include <Windows.h>
#include <filesystem>
#include <mutex>
#include <unordered_map>
#include <sstream>
#include <fstream>
#include <algorithm>

namespace fs = std::filesystem;

// Helper class for Python DLL function pointers
class PythonDllFunctions {
public:
    // Core Python C API function pointers
    void (*Py_Initialize)(void) = nullptr;
    void (*Py_InitializeEx)(int) = nullptr;
    void (*Py_Finalize)(void) = nullptr;
    int (*Py_FinalizeEx)(void) = nullptr;
    int (*Py_IsInitialized)(void) = nullptr;
    void (*Py_SetPythonHome)(const wchar_t*) = nullptr;
    void (*Py_SetPath)(const wchar_t*) = nullptr;
    const char* (*Py_GetVersion)(void) = nullptr;
    void (*PyErr_Print)(void) = nullptr;
    void (*PyErr_Clear)(void) = nullptr;
    
    // Additional useful functions
    int (*PyRun_SimpleString)(const char*) = nullptr;
    void* (*PyImport_AddModule)(const char*) = nullptr;
    
    bool LoadFromDll(HMODULE pythonDll) {
        if (!pythonDll) return false;
        
        // Load function pointers
        #define LOAD_FUNC(name) \
            name = (decltype(name))GetProcAddress(pythonDll, #name); \
            if (!name) return false;
        
        LOAD_FUNC(Py_Initialize);
        LOAD_FUNC(Py_Finalize);
        LOAD_FUNC(Py_IsInitialized);
        
        // Optional functions (don't fail if not found)
        #define LOAD_FUNC_OPT(name) \
            name = (decltype(name))GetProcAddress(pythonDll, #name);
        
        LOAD_FUNC_OPT(Py_InitializeEx);
        LOAD_FUNC_OPT(Py_FinalizeEx);
        LOAD_FUNC_OPT(Py_SetPythonHome);
        LOAD_FUNC_OPT(Py_SetPath);
        LOAD_FUNC_OPT(Py_GetVersion);
        LOAD_FUNC_OPT(PyErr_Print);
        LOAD_FUNC_OPT(PyErr_Clear);
        LOAD_FUNC_OPT(PyRun_SimpleString);
        LOAD_FUNC_OPT(PyImport_AddModule);
        
        #undef LOAD_FUNC
        #undef LOAD_FUNC_OPT
        
        return true;
    }
};

// Implementation of Python environment
class PythonEnvironment : public IPythonEnvironment {
private:
    // Configuration
    std::string m_condaPath;
    std::string m_pythonVersion;
    std::map<std::string, std::string> m_environmentInfo;
    
    // Python DLL handling
    HMODULE m_pythonDll = nullptr;
    HMODULE m_bridgeDll = nullptr;
    PythonDllFunctions m_pyFuncs;
    
    // Bridge
    std::unique_ptr<IPythonBridge> m_bridge;
    
    // State
    bool m_initialized = false;
    bool m_ownsInterpreter = false;  // Did we initialize Python?
    mutable std::mutex m_mutex;
    
    // Error handling
    std::string m_lastError;
    
public:
    explicit PythonEnvironment(const std::string& condaPath) 
        : m_condaPath(condaPath) {
        // Normalize path
        m_condaPath = fs::absolute(condaPath).string();
        m_environmentInfo["conda_path"] = m_condaPath;
    }
    
    ~PythonEnvironment() {
        Shutdown();
    }
    
    // IPythonEnvironment implementation
    bool Initialize() override {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_initialized) {
            return true;
        }
        
        try {
            // Step 1: Validate environment
            if (!ValidateEnvironment()) {
                return false;
            }
            
            // Step 2: Setup environment variables
            if (!SetupEnvironment()) {
                return false;
            }
            
            // Step 3: Load Python DLL
            if (!LoadPythonDll()) {
                return false;
            }
            
            // Step 4: Initialize Python if needed
            if (!InitializePython()) {
                Cleanup();
                return false;
            }
            
            // Step 5: Load bridge module
            if (!LoadBridgeModule()) {
                Cleanup();
                return false;
            }
            
            // Step 6: Verify functionality
            if (!VerifyEnvironment()) {
                Cleanup();
                return false;
            }
            
            m_initialized = true;
            m_environmentInfo["initialized"] = "true";
            m_environmentInfo["python_version"] = m_pythonVersion;
            
            return true;
        }
        catch (const std::exception& e) {
            m_lastError = std::string("Exception during initialization: ") + e.what();
            Cleanup();
            return false;
        }
    }
    
    void Shutdown() override {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (!m_initialized) {
            return;
        }
        
        // Release bridge first
        m_bridge.reset();
        
        // Finalize Python if we initialized it
        if (m_ownsInterpreter && m_pyFuncs.Py_Finalize && 
            m_pyFuncs.Py_IsInitialized && m_pyFuncs.Py_IsInitialized()) {
            
            // Try graceful finalization first
            if (m_pyFuncs.Py_FinalizeEx) {
                m_pyFuncs.Py_FinalizeEx();
            } else {
                m_pyFuncs.Py_Finalize();
            }
        }
        
        // Unload modules
        if (m_bridgeDll) {
            FreeLibrary(m_bridgeDll);
            m_bridgeDll = nullptr;
        }
        
        if (m_pythonDll) {
            FreeLibrary(m_pythonDll);
            m_pythonDll = nullptr;
        }
        
        m_initialized = false;
        m_ownsInterpreter = false;
        m_environmentInfo["initialized"] = "false";
    }
    
    bool IsInitialized() const override {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_initialized;
    }
    
    IPythonBridge* GetBridge() override {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_bridge.get();
    }
    
    std::string GetEnvironmentPath() const override {
        return m_condaPath;
    }
    
    std::string GetPythonVersion() const override {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_pythonVersion;
    }
    
    std::map<std::string, std::string> GetEnvironmentInfo() const override {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_environmentInfo;
    }
    
    std::string GetLastError() const {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_lastError;
    }
    
private:
    bool ValidateEnvironment() {
        fs::path envPath(m_condaPath);
        
        // Check if environment exists
        if (!fs::exists(envPath)) {
            m_lastError = "Environment path does not exist: " + m_condaPath;
            return false;
        }
        
        // Check for essential directories
        std::vector<std::string> requiredDirs = {"Lib", "DLLs", "Scripts"};
        for (const auto& dir : requiredDirs) {
            if (!fs::exists(envPath / dir)) {
                m_lastError = "Missing required directory: " + dir;
                return false;
            }
        }
        
        // Check for Python executable (to verify it's a Python environment)
        bool foundPython = false;
        for (const auto& entry : fs::directory_iterator(envPath)) {
            if (entry.is_regular_file()) {
                std::string filename = entry.path().filename().string();
                if (filename.find("python.exe") != std::string::npos) {
                    foundPython = true;
                    break;
                }
            }
        }
        
        if (!foundPython) {
            m_lastError = "No Python executable found in environment";
            return false;
        }
        
        return true;
    }
    
    bool SetupEnvironment() {
        // Save current environment for restoration if needed
        char* oldPath = nullptr;
        size_t oldPathSize = GetEnvironmentVariableA("PATH", nullptr, 0);
        if (oldPathSize > 0) {
            oldPath = new char[oldPathSize];
            GetEnvironmentVariableA("PATH", oldPath, oldPathSize);
        }
        
        try {
            // Build new PATH
            std::stringstream newPath;
            newPath << m_condaPath << ";";
            newPath << m_condaPath << "\\Scripts;";
            newPath << m_condaPath << "\\Library\\bin;";
            newPath << m_condaPath << "\\DLLs;";
            
            if (oldPath) {
                newPath << oldPath;
            }
            
            // Set environment variables
            if (!SetEnvironmentVariableA("PATH", newPath.str().c_str())) {
                m_lastError = "Failed to set PATH environment variable";
                delete[] oldPath;
                return false;
            }
            
            // Set PYTHONHOME
            if (!SetEnvironmentVariableA("PYTHONHOME", m_condaPath.c_str())) {
                m_lastError = "Failed to set PYTHONHOME environment variable";
                delete[] oldPath;
                return false;
            }
            
            // Clear PYTHONPATH to avoid conflicts
            SetEnvironmentVariableA("PYTHONPATH", "");
            
            // Set additional conda environment variables
            SetEnvironmentVariableA("CONDA_PREFIX", m_condaPath.c_str());
            SetEnvironmentVariableA("CONDA_DEFAULT_ENV", 
                                   fs::path(m_condaPath).filename().string().c_str());
            
            delete[] oldPath;
            return true;
        }
        catch (...) {
            delete[] oldPath;
            m_lastError = "Exception while setting up environment";
            return false;
        }
    }
    
    bool LoadPythonDll() {
        fs::path envPath(m_condaPath);
        
        // Try to find python3*.dll
        std::vector<fs::path> pythonDlls;
        for (const auto& entry : fs::directory_iterator(envPath)) {
            if (entry.is_regular_file()) {
                std::string filename = entry.path().filename().string();
                if (filename.starts_with("python3") && filename.ends_with(".dll")) {
                    pythonDlls.push_back(entry.path());
                }
            }
        }
        
        if (pythonDlls.empty()) {
            m_lastError = "No Python DLL found in environment";
            return false;
        }
        
        // Sort to get the highest version (e.g., python39.dll over python38.dll)
        std::sort(pythonDlls.begin(), pythonDlls.end());
        
        // Try to load the DLL
        for (const auto& dllPath : pythonDlls) {
            m_pythonDll = LoadLibraryA(dllPath.string().c_str());
            if (m_pythonDll) {
                // Extract version from filename
                std::string filename = dllPath.filename().string();
                m_pythonVersion = ExtractPythonVersion(filename);
                
                // Load Python functions
                if (m_pyFuncs.LoadFromDll(m_pythonDll)) {
                    // Try to get version from Python itself
                    if (m_pyFuncs.Py_GetVersion) {
                        const char* version = m_pyFuncs.Py_GetVersion();
                        if (version) {
                            m_pythonVersion = std::string(version);
                            // Extract just the version number
                            size_t spacePos = m_pythonVersion.find(' ');
                            if (spacePos != std::string::npos) {
                                m_pythonVersion = m_pythonVersion.substr(0, spacePos);
                            }
                        }
                    }
                    
                    return true;
                }
                
                // Failed to load functions, try next DLL
                FreeLibrary(m_pythonDll);
                m_pythonDll = nullptr;
            }
        }
        
        m_lastError = "Failed to load Python DLL or its functions";
        return false;
    }
    
    bool InitializePython() {
        if (!m_pyFuncs.Py_IsInitialized || !m_pyFuncs.Py_Initialize) {
            m_lastError = "Python initialization functions not available";
            return false;
        }
        
        // Check if Python is already initialized (by another environment)
        if (m_pyFuncs.Py_IsInitialized()) {
            m_ownsInterpreter = false;
            return true;
        }
        
        // Set Python home before initialization
        if (m_pyFuncs.Py_SetPythonHome) {
            std::wstring widePath(m_condaPath.begin(), m_condaPath.end());
            m_pyFuncs.Py_SetPythonHome(widePath.c_str());
        }
        
        // Initialize Python
        if (m_pyFuncs.Py_InitializeEx) {
            // Skip signal handler registration for embedded Python
            m_pyFuncs.Py_InitializeEx(0);
        } else {
            m_pyFuncs.Py_Initialize();
        }
        
        // Verify initialization
        if (!m_pyFuncs.Py_IsInitialized()) {
            m_lastError = "Python initialization failed";
            return false;
        }
        
        m_ownsInterpreter = true;
        
        // Clear any initialization errors
        if (m_pyFuncs.PyErr_Clear) {
            m_pyFuncs.PyErr_Clear();
        }
        
        return true;
    }
    
    bool LoadBridgeModule() {
        // Look for pythonbridge.pyd in site-packages
        fs::path bridgePath = fs::path(m_condaPath) / "Lib" / "site-packages" / "pythonbridge.pyd";
        
        // Also check for version-specific names
        if (!fs::exists(bridgePath)) {
            std::string versionTag = GetPythonVersionTag();
            bridgePath = fs::path(m_condaPath) / "Lib" / "site-packages" / 
                        ("pythonbridge.cp" + versionTag + "-win_amd64.pyd");
        }
        
        if (!fs::exists(bridgePath)) {
            m_lastError = "Python bridge module not found. Please install pythonbridge.pyd in site-packages";
            return false;
        }
        
        // Load the bridge module
        m_bridgeDll = LoadLibraryA(bridgePath.string().c_str());
        if (!m_bridgeDll) {
            DWORD error = GetLastError();
            m_lastError = "Failed to load bridge module. Error code: " + std::to_string(error);
            return false;
        }
        
        // Get the factory function
        using CreateBridgeFunc = IPythonBridge* (*)(void);
        CreateBridgeFunc createBridge = (CreateBridgeFunc)GetProcAddress(m_bridgeDll, "CreatePythonBridge");
        
        if (!createBridge) {
            m_lastError = "CreatePythonBridge function not found in bridge module";
            FreeLibrary(m_bridgeDll);
            m_bridgeDll = nullptr;
            return false;
        }
        
        // Create the bridge
        IPythonBridge* bridge = createBridge();
        if (!bridge) {
            m_lastError = "Failed to create Python bridge instance";
            FreeLibrary(m_bridgeDll);
            m_bridgeDll = nullptr;
            return false;
        }
        
        m_bridge.reset(bridge);
        return true;
    }
    
    bool VerifyEnvironment() {
        if (!m_bridge) {
            m_lastError = "Bridge not initialized";
            return false;
        }
        
        // Try a simple Python operation
        auto result = m_bridge->ExecuteString("import sys");
        if (!result.success) {
            m_lastError = "Failed to import sys module: " + result.error;
            return false;
        }
        
        // Get Python version for verification
        result = m_bridge->ExecuteString("python_version = sys.version");
        if (!result.success) {
            m_lastError = "Failed to get Python version: " + result.error;
            return false;
        }
        
        return true;
    }
    
    void Cleanup() {
        if (m_bridge) {
            m_bridge.reset();
        }
        
        if (m_bridgeDll) {
            FreeLibrary(m_bridgeDll);
            m_bridgeDll = nullptr;
        }
        
        if (m_ownsInterpreter && m_pyFuncs.Py_Finalize && 
            m_pyFuncs.Py_IsInitialized && m_pyFuncs.Py_IsInitialized()) {
            m_pyFuncs.Py_Finalize();
        }
        
        if (m_pythonDll) {
            FreeLibrary(m_pythonDll);
            m_pythonDll = nullptr;
        }
        
        m_initialized = false;
        m_ownsInterpreter = false;
    }
    
    std::string ExtractPythonVersion(const std::string& dllName) {
        // Extract version from python3X.dll or python3XY.dll
        std::string version;
        size_t pos = dllName.find("python3");
        if (pos != std::string::npos) {
            pos += 7; // Skip "python3"
            if (pos < dllName.length() && isdigit(dllName[pos])) {
                version = "3.";
                version += dllName[pos];
                if (pos + 1 < dllName.length() && isdigit(dllName[pos + 1])) {
                    version += ".";
                    version += dllName[pos + 1];
                }
            }
        }
        return version.empty() ? "3.x" : version;
    }
    
    std::string GetPythonVersionTag() {
        // Convert "3.9.x" to "39" for .pyd naming
        std::string tag;
        if (m_pythonVersion.length() >= 3) {
            tag += m_pythonVersion[0];  // '3'
            tag += m_pythonVersion[2];  // '9' (skip the dot)
            if (m_pythonVersion.length() >= 5 && m_pythonVersion[3] == '.') {
                tag += m_pythonVersion[4];
            }
        }
        return tag;
    }
};

// Implementation of environment manager
class PythonEnvironmentManager : public IPythonEnvironmentManager {
private:
    std::unordered_map<std::string, std::shared_ptr<PythonEnvironment>> m_environments;
    mutable std::mutex m_mutex;
    bool m_shutdownInProgress = false;
    
public:
    PythonEnvironmentManager() = default;
    
    ~PythonEnvironmentManager() {
        ShutdownAll();
    }
    
    std::shared_ptr<IPythonEnvironment> GetEnvironment(const std::string& condaPath) override {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (m_shutdownInProgress) {
            return nullptr;
        }
        
        // Normalize path for consistent key
        fs::path normalizedPath;
        try {
            normalizedPath = fs::absolute(condaPath);
        } catch (const std::exception&) {
            return nullptr;
        }
        
        std::string key = normalizedPath.string();
        
        // Check if already exists
        auto it = m_environments.find(key);
        if (it != m_environments.end()) {
            return it->second;
        }
        
        // Create new environment
        auto env = std::make_shared<PythonEnvironment>(key);
        m_environments[key] = env;
        
        return env;
    }
    
    std::vector<std::string> GetActiveEnvironments() const override {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        std::vector<std::string> paths;
        paths.reserve(m_environments.size());
        
        for (const auto& [path, env] : m_environments) {
            if (env && env->IsInitialized()) {
                paths.push_back(path);
            }
        }
        
        return paths;
    }
    
    void ShutdownEnvironment(const std::string& condaPath) override {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        fs::path normalizedPath;
        try {
            normalizedPath = fs::absolute(condaPath);
        } catch (const std::exception&) {
            return;
        }
        
        std::string key = normalizedPath.string();
        
        auto it = m_environments.find(key);
        if (it != m_environments.end()) {
            if (it->second) {
                it->second->Shutdown();
            }
            m_environments.erase(it);
        }
    }
    
    void ShutdownAll() override {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        m_shutdownInProgress = true;
        
        // Shutdown all environments
        for (auto& [path, env] : m_environments) {
            if (env) {
                env->Shutdown();
            }
        }
        
        m_environments.clear();
    }
    
    void RegisterBridgeFactory(const std::string& pythonVersion, 
                               BridgeFactoryFunc factory) override {
        // This functionality could be extended to support dynamic bridge loading
        // For now, we rely on the pythonbridge.pyd in each environment
    }
};

// Factory function implementations
extern "C" {
    PYENV_API IPythonEnvironmentManager* CreatePythonEnvironmentManager() {
        return new PythonEnvironmentManager();
    }
    
    PYENV_API void DestroyPythonEnvironmentManager(IPythonEnvironmentManager* manager) {
        delete manager;
    }
}
//===================================
// ThreadSafePythonEnvironment.h - Thread-safe Python initialization/finalization
#pragma once

#include "IPythonEnvironment.h"
#include <Windows.h>
#include <thread>
#include <atomic>
#include <condition_variable>
#include <queue>
#include <future>

// Thread-safe Python state manager
class PythonThreadStateManager {
private:
    struct PythonThreadState {
        std::thread::id initThread;
        DWORD initThreadId;  // Windows thread ID
        void* pyThreadState;  // PyThreadState*
        bool isMainInterpreter;
        std::chrono::system_clock::time_point initTime;
    };
    
    static std::mutex s_globalMutex;
    static std::map<void*, PythonThreadState> s_interpreterStates;  // PyInterpreterState* -> ThreadState
    static std::thread::id s_mainInitThread;
    static bool s_pythonEverInitialized;
    
public:
    static void RegisterInitialization(void* interpreter, bool isMain) {
        std::lock_guard<std::mutex> lock(s_globalMutex);
        
        PythonThreadState state;
        state.initThread = std::this_thread::get_id();
        state.initThreadId = GetCurrentThreadId();
        state.pyThreadState = nullptr;  // Will be set later if needed
        state.isMainInterpreter = isMain;
        state.initTime = std::chrono::system_clock::now();
        
        s_interpreterStates[interpreter] = state;
        
        if (isMain) {
            s_mainInitThread = state.initThread;
            s_pythonEverInitialized = true;
        }
    }
    
    static bool IsInitializingThread(void* interpreter) {
        std::lock_guard<std::mutex> lock(s_globalMutex);
        auto it = s_interpreterStates.find(interpreter);
        if (it != s_interpreterStates.end()) {
            return it->second.initThread == std::this_thread::get_id();
        }
        return false;
    }
    
    static std::thread::id GetInitializingThread(void* interpreter) {
        std::lock_guard<std::mutex> lock(s_globalMutex);
        auto it = s_interpreterStates.find(interpreter);
        if (it != s_interpreterStates.end()) {
            return it->second.initThread;
        }
        return std::thread::id();
    }
    
    static void UnregisterInterpreter(void* interpreter) {
        std::lock_guard<std::mutex> lock(s_globalMutex);
        s_interpreterStates.erase(interpreter);
    }
};

// Static member definitions
std::mutex PythonThreadStateManager::s_globalMutex;
std::map<void*, PythonThreadStateManager::PythonThreadState> PythonThreadStateManager::s_interpreterStates;
std::thread::id PythonThreadStateManager::s_mainInitThread;
bool PythonThreadStateManager::s_pythonEverInitialized = false;

// Thread-safe finalization coordinator
class PythonFinalizationCoordinator {
private:
    struct FinalizationRequest {
        std::promise<bool> promise;
        std::function<void()> finalizer;
        std::thread::id targetThread;
    };
    
    static std::mutex s_mutex;
    static std::condition_variable s_cv;
    static std::queue<FinalizationRequest> s_requests;
    static std::atomic<bool> s_running;
    static std::thread s_coordinatorThread;
    
public:
    static void Start() {
        bool expected = false;
        if (s_running.compare_exchange_strong(expected, true)) {
            s_coordinatorThread = std::thread(CoordinatorLoop);
        }
    }
    
    static void Stop() {
        s_running = false;
        s_cv.notify_all();
        if (s_coordinatorThread.joinable()) {
            s_coordinatorThread.join();
        }
    }
    
    static std::future<bool> RequestFinalization(
        std::thread::id targetThread, 
        std::function<void()> finalizer) {
        
        FinalizationRequest request;
        request.targetThread = targetThread;
        request.finalizer = std::move(finalizer);
        auto future = request.promise.get_future();
        
        {
            std::lock_guard<std::mutex> lock(s_mutex);
            s_requests.push(std::move(request));
        }
        
        s_cv.notify_one();
        return future;
    }
    
private:
    static void CoordinatorLoop() {
        while (s_running) {
            std::unique_lock<std::mutex> lock(s_mutex);
            s_cv.wait(lock, [] { return !s_requests.empty() || !s_running; });
            
            while (!s_requests.empty()) {
                auto request = std::move(s_requests.front());
                s_requests.pop();
                lock.unlock();
                
                // Execute finalization
                try {
                    request.finalizer();
                    request.promise.set_value(true);
                } catch (...) {
                    request.promise.set_value(false);
                }
                
                lock.lock();
            }
        }
    }
};

// Static definitions
std::mutex PythonFinalizationCoordinator::s_mutex;
std::condition_variable PythonFinalizationCoordinator::s_cv;
std::queue<PythonFinalizationCoordinator::FinalizationRequest> PythonFinalizationCoordinator::s_requests;
std::atomic<bool> PythonFinalizationCoordinator::s_running{false};
std::thread PythonFinalizationCoordinator::s_coordinatorThread;

// Enhanced Python environment with thread safety
class ThreadSafePythonEnvironment : public PythonEnvironment {
private:
    // Thread tracking
    std::thread::id m_initializingThread;
    HANDLE m_initializingThreadHandle = nullptr;
    void* m_interpreterState = nullptr;  // PyInterpreterState*
    
    // Additional thread safety
    std::atomic<bool> m_finalizationRequested{false};
    std::condition_variable m_finalizationCv;
    std::mutex m_finalizationMutex;
    
    // Enhanced Python function pointers
    void* (*m_PyInterpreterState_Get)(void) = nullptr;
    void* (*m_PyThreadState_Get)(void) = nullptr;
    void* (*m_PyThreadState_Swap)(void*) = nullptr;
    void (*m_PyEval_RestoreThread)(void*) = nullptr;
    void* (*m_PyEval_SaveThread)(void) = nullptr;
    int (*m_PyGILState_Ensure)(void) = nullptr;
    void (*m_PyGILState_Release)(int) = nullptr;
    
public:
    ThreadSafePythonEnvironment(const std::string& condaPath) 
        : PythonEnvironment(condaPath) {
        PythonFinalizationCoordinator::Start();
    }
    
    ~ThreadSafePythonEnvironment() {
        SafeShutdown();
    }
    
protected:
    bool InitializePython() override {
        if (!m_pyFuncs.Py_IsInitialized || !m_pyFuncs.Py_Initialize) {
            m_lastError = "Python initialization functions not available";
            return false;
        }
        
        // Load additional thread-related functions
        LoadThreadFunctions();
        
        // Check if Python is already initialized
        if (m_pyFuncs.Py_IsInitialized()) {
            m_ownsInterpreter = false;
            
            // Get current interpreter state
            if (m_PyInterpreterState_Get) {
                m_interpreterState = m_PyInterpreterState_Get();
            }
            
            return true;
        }
        
        // Record the initializing thread
        m_initializingThread = std::this_thread::get_id();
        m_initializingThreadHandle = OpenThread(THREAD_ALL_ACCESS, FALSE, GetCurrentThreadId());
        
        // Set Python home before initialization
        if (m_pyFuncs.Py_SetPythonHome) {
            std::wstring widePath(m_condaPath.begin(), m_condaPath.end());
            m_pyFuncs.Py_SetPythonHome(widePath.c_str());
        }
        
        // Initialize Python
        if (m_pyFuncs.Py_InitializeEx) {
            m_pyFuncs.Py_InitializeEx(0);  // Skip signal handlers
        } else {
            m_pyFuncs.Py_Initialize();
        }
        
        // Verify initialization
        if (!m_pyFuncs.Py_IsInitialized()) {
            m_lastError = "Python initialization failed";
            return false;
        }
        
        m_ownsInterpreter = true;
        
        // Get interpreter state
        if (m_PyInterpreterState_Get) {
            m_interpreterState = m_PyInterpreterState_Get();
            PythonThreadStateManager::RegisterInitialization(m_interpreterState, true);
        }
        
        // Clear any initialization errors
        if (m_pyFuncs.PyErr_Clear) {
            m_pyFuncs.PyErr_Clear();
        }
        
        return true;
    }
    
    void Shutdown() override {
        SafeShutdown();
    }
    
private:
    void LoadThreadFunctions() {
        if (!m_pythonDll) return;
        
        m_PyInterpreterState_Get = (void*(*)(void))GetProcAddress(m_pythonDll, "PyInterpreterState_Get");
        m_PyThreadState_Get = (void*(*)(void))GetProcAddress(m_pythonDll, "PyThreadState_Get");
        m_PyThreadState_Swap = (void*(*)(void*))GetProcAddress(m_pythonDll, "PyThreadState_Swap");
        m_PyEval_RestoreThread = (void(*)(void*))GetProcAddress(m_pythonDll, "PyEval_RestoreThread");
        m_PyEval_SaveThread = (void*(*)(void))GetProcAddress(m_pythonDll, "PyEval_SaveThread");
        m_PyGILState_Ensure = (int(*)(void))GetProcAddress(m_pythonDll, "PyGILState_Ensure");
        m_PyGILState_Release = (void(*)(int))GetProcAddress(m_pythonDll, "PyGILState_Release");
    }
    
    void SafeShutdown() {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (!m_initialized || m_finalizationRequested.exchange(true)) {
            return;
        }
        
        // Release bridge first (this is safe from any thread)
        m_bridge.reset();
        
        // Handle Python finalization
        if (m_ownsInterpreter && m_pyFuncs.Py_Finalize && 
            m_pyFuncs.Py_IsInitialized && m_pyFuncs.Py_IsInitialized()) {
            
            if (std::this_thread::get_id() == m_initializingThread) {
                // We're on the correct thread, finalize directly
                FinalizePythonDirect();
            } else {
                // We're on a different thread, need special handling
                FinalizePythonCrossThread();
            }
        }
        
        // Unload modules (safe from any thread)
        if (m_bridgeDll) {
            FreeLibrary(m_bridgeDll);
            m_bridgeDll = nullptr;
        }
        
        if (m_pythonDll) {
            FreeLibrary(m_pythonDll);
            m_pythonDll = nullptr;
        }
        
        // Clean up thread handle
        if (m_initializingThreadHandle) {
            CloseHandle(m_initializingThreadHandle);
            m_initializingThreadHandle = nullptr;
        }
        
        // Unregister from thread state manager
        if (m_interpreterState) {
            PythonThreadStateManager::UnregisterInterpreter(m_interpreterState);
        }
        
        m_initialized = false;
        m_ownsInterpreter = false;
    }
    
    void FinalizePythonDirect() {
        // We're on the correct thread, safe to finalize
        if (m_pyFuncs.Py_FinalizeEx) {
            m_pyFuncs.Py_FinalizeEx();
        } else {
            m_pyFuncs.Py_Finalize();
        }
    }
    
    void FinalizePythonCrossThread() {
        // Complex case: we need to finalize from a different thread
        
        // Option 1: Try to use QueueUserAPC to run on the original thread
        if (m_initializingThreadHandle && TryQueueFinalization()) {
            return;
        }
        
        // Option 2: Use Python's thread state API if available
        if (TryPythonThreadStateFinalization()) {
            return;
        }
        
        // Option 3: Force finalization with safety checks
        ForceFinalizationWithSafety();
    }
    
    bool TryQueueFinalization() {
        // This only works if the target thread is in an alertable wait state
        struct FinalizationContext {
            ThreadSafePythonEnvironment* env;
            std::atomic<bool> completed;
        };
        
        auto context = std::make_shared<FinalizationContext>();
        context->env = this;
        context->completed = false;
        
        auto apcFunc = [](ULONG_PTR param) -> void {
            auto ctx = reinterpret_cast<FinalizationContext*>(param);
            ctx->env->FinalizePythonDirect();
            ctx->completed = true;
        };
        
        if (QueueUserAPC(apcFunc, m_initializingThreadHandle, 
                         reinterpret_cast<ULONG_PTR>(context.get()))) {
            
            // Wait for completion with timeout
            auto start = std::chrono::steady_clock::now();
            while (!context->completed && 
                   std::chrono::steady_clock::now() - start < std::chrono::seconds(5)) {
                std::this_thread::sleep_for(std::chrono::milliseconds(10));
            }
            
            return context->completed;
        }
        
        return false;
    }
    
    bool TryPythonThreadStateFinalization() {
        if (!m_PyThreadState_Get || !m_PyThreadState_Swap || 
            !m_PyEval_SaveThread || !m_PyEval_RestoreThread) {
            return false;
        }
        
        try {
            // Save current thread state
            void* savedState = m_PyEval_SaveThread();
            
            // Perform finalization
            if (m_pyFuncs.Py_FinalizeEx) {
                m_pyFuncs.Py_FinalizeEx();
            } else {
                m_pyFuncs.Py_Finalize();
            }
            
            return true;
        } catch (...) {
            return false;
        }
    }
    
    void ForceFinalizationWithSafety() {
        // Last resort: finalize with safety checks
        std::cerr << "WARNING: Python finalization requested from different thread. "
                  << "This may cause issues." << std::endl;
        
        // Try to ensure no Python code is running
        if (m_PyGILState_Ensure && m_PyGILState_Release) {
            int gilState = m_PyGILState_Ensure();
            
            // Clear any pending errors
            if (m_pyFuncs.PyErr_Clear) {
                m_pyFuncs.PyErr_Clear();
            }
            
            // Release GIL before finalization
            m_PyGILState_Release(gilState);
        }
        
        // Add a small delay to let any Python threads complete
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        
        // Finalize
        if (m_pyFuncs.Py_FinalizeEx) {
            m_pyFuncs.Py_FinalizeEx();
        } else {
            m_pyFuncs.Py_Finalize();
        }
    }
};

// Usage example with thread safety demonstration
class ThreadSafeUsageExample {
public:
    static void Demonstrate() {
        auto manager = CreatePythonEnvironmentManager();
        
        // Scenario 1: Initialization and finalization on same thread
        {
            std::thread worker([&manager]() {
                auto env = std::static_pointer_cast<ThreadSafePythonEnvironment>(
                    manager->GetEnvironment("C:\\Python\\envs\\test1"));
                
                env->Initialize();
                auto bridge = env->GetBridge();
                bridge->ExecuteString("print('Same thread init/finalize')");
                
                // Shutdown on same thread - safe
                env->Shutdown();
            });
            worker.join();
        }
        
        // Scenario 2: Cross-thread finalization
        {
            std::shared_ptr<IPythonEnvironment> env;
            
            std::thread initThread([&env, &manager]() {
                env = manager->GetEnvironment("C:\\Python\\envs\\test2");
                env->Initialize();
                
                auto bridge = env->GetBridge();
                bridge->ExecuteString("print('Initialized on thread 1')");
            });
            initThread.join();
            
            std::thread finalizeThread([&env]() {
                std::cout << "Finalizing from different thread..." << std::endl;
                env->Shutdown();  // Cross-thread finalization handled safely
            });
            finalizeThread.join();
        }
        
        // Scenario 3: Multiple threads using same environment
        {
            auto env = manager->GetEnvironment("C:\\Python\\envs\\test3");
            env->Initialize();
            
            std::vector<std::thread> workers;
            
            for (int i = 0; i < 4; ++i) {
                workers.emplace_back([&env, i]() {
                    auto bridge = env->GetBridge();
                    
                    // Each thread needs GIL for Python operations
                    for (int j = 0; j < 10; ++j) {
                        auto result = bridge->ExecuteString(
                            "import threading; "
                            "print(f'Thread " + std::to_string(i) + 
                            " operation " + std::to_string(j) + 
                            ": {threading.current_thread().name}')");
                    }
                });
            }
            
            for (auto& t : workers) {
                t.join();
            }
            
            // Shutdown after all threads complete
            env->Shutdown();
        }
        
        DestroyPythonEnvironmentManager(manager);
    }
};


/////====================================
// EnhancedPythonEnvironment.h - Python environment with optimal ThreadState management
#pragma once

#include "PythonThreadStateManager.h"
#include "IPythonEnvironment.h"
#include <memory>
#include <future>

class EnhancedPythonEnvironment : public PythonEnvironment {
private:
    // Thread state management
    std::unique_ptr<PythonThreadStateManager> m_threadStateManager;
    
    // Enhanced state tracking
    std::atomic<int> m_activeOperations{0};
    std::condition_variable m_operationsCv;
    std::mutex m_operationsMutex;
    
    // Finalization strategy
    enum class FinalizationStrategy {
        SameThread,           // Finalize on initialization thread
        ThreadStateSwap,      // Use PyThreadState_Swap
        QueueToOriginal,      // Queue APC to original thread
        ForceWithGIL          // Force with GIL acquisition
    };
    
public:
    EnhancedPythonEnvironment(const std::string& condaPath)
        : PythonEnvironment(condaPath)
        , m_threadStateManager(std::make_unique<PythonThreadStateManager>()) {
    }
    
    ~EnhancedPythonEnvironment() {
        OptimalShutdown();
    }
    
protected:
    bool InitializePython() override {
        // First initialize thread state manager
        if (m_pythonDll && !m_threadStateManager->Initialize(m_pythonDll)) {
            m_lastError = "Failed to initialize thread state manager";
            return false;
        }
        
        // Call base initialization
        if (!PythonEnvironment::InitializePython()) {
            return false;
        }
        
        // Capture thread state immediately after initialization
        if (!m_threadStateManager->CaptureCurrentThreadState(true)) {
            m_lastError = "Failed to capture main thread state";
            return false;
        }
        
        // Set up thread state for all threads that will use Python
        SetupThreadStateHooks();
        
        return true;
    }
    
    void Shutdown() override {
        OptimalShutdown();
    }
    
public:
    // Thread-safe Python execution with operation tracking
    template<typename Func>
    auto ExecutePythonSafely(Func&& func) -> decltype(func()) {
        // Track active operations
        {
            std::lock_guard<std::mutex> lock(m_operationsMutex);
            m_activeOperations++;
        }
        
        // Ensure cleanup on scope exit
        auto cleanup = [this]() {
            std::lock_guard<std::mutex> lock(m_operationsMutex);
            m_activeOperations--;
            m_operationsCv.notify_all();
        };
        
        struct ScopeGuard {
            std::function<void()> f;
            ~ScopeGuard() { f(); }
        } guard{cleanup};
        
        // Execute on appropriate thread
        return m_threadStateManager->ExecuteOnPythonThread(std::forward<Func>(func));
    }
    
    // Register a thread for Python usage
    bool RegisterThreadForPython(const std::string& threadName = "") {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (!m_initialized || !m_threadStateManager) {
            return false;
        }
        
        // Set thread name if provided
        if (!threadName.empty()) {
            SetThreadDescription(GetCurrentThread(), 
                               std::wstring(threadName.begin(), threadName.end()).c_str());
        }
        
        // Capture thread state
        return m_threadStateManager->CaptureCurrentThreadState(false);
    }
    
    // Get optimal finalization strategy
    FinalizationStrategy DetermineFinalizationStrategy() {
        auto currentThread = std::this_thread::get_id();
        auto threadInfo = m_threadStateManager->GetThreadStateInfo(currentThread);
        
        if (threadInfo && threadInfo->isMainThread) {
            return FinalizationStrategy::SameThread;
        } else if (threadInfo && threadInfo->pyThreadState) {
            return FinalizationStrategy::ThreadStateSwap;
        } else {
            // Check if we can queue to original thread
            auto mainInfo = m_threadStateManager->GetThreadStateInfo(m_initializingThread);
            if (mainInfo && mainInfo->threadHandle) {
                return FinalizationStrategy::QueueToOriginal;
            }
        }
        
        return FinalizationStrategy::ForceWithGIL;
    }
    
private:
    void OptimalShutdown() {
        std::lock_guard<std::mutex> lock(m_mutex);
        
        if (!m_initialized || m_finalizationRequested.exchange(true)) {
            return;
        }
        
        // Wait for active operations to complete
        WaitForActiveOperations();
        
        // Release bridge first
        m_bridge.reset();
        
        // Determine best finalization strategy
        auto strategy = DetermineFinalizationStrategy();
        
        LogDebug("Finalization strategy: " + GetStrategyName(strategy));
        
        // Perform finalization based on strategy
        bool finalized = false;
        
        switch (strategy) {
            case FinalizationStrategy::SameThread:
                finalized = FinalizeSameThread();
                break;
                
            case FinalizationStrategy::ThreadStateSwap:
                finalized = FinalizeWithThreadStateSwap();
                break;
                
            case FinalizationStrategy::QueueToOriginal:
                finalized = FinalizeQueueToOriginal();
                break;
                
            case FinalizationStrategy::ForceWithGIL:
                finalized = FinalizeForceWithGIL();
                break;
        }
        
        if (!finalized) {
            LogError("Failed to finalize Python properly");
        }
        
        // Clean up thread states
        if (m_threadStateManager) {
            m_threadStateManager->ShutdownAllThreadStates();
        }
        
        // Unload modules
        if (m_bridgeDll) {
            FreeLibrary(m_bridgeDll);
            m_bridgeDll = nullptr;
        }
        
        if (m_pythonDll) {
            FreeLibrary(m_pythonDll);
            m_pythonDll = nullptr;
        }
        
        m_initialized = false;
        m_ownsInterpreter = false;
    }
    
    void WaitForActiveOperations() {
        std::unique_lock<std::mutex> lock(m_operationsMutex);
        
        auto timeout = std::chrono::seconds(30);
        auto start = std::chrono::steady_clock::now();
        
        while (m_activeOperations > 0) {
            auto elapsed = std::chrono::steady_clock::now() - start;
            if (elapsed > timeout) {
                LogError("Timeout waiting for active operations to complete");
                break;
            }
            
            m_operationsCv.wait_for(lock, std::chrono::milliseconds(100));
        }
    }
    
    bool FinalizeSameThread() {
        // Simple case - we're on the right thread
        return m_threadStateManager->FinalizeWithThreadState([this]() {
            if (m_pyFuncs.Py_FinalizeEx) {
                m_pyFuncs.Py_FinalizeEx();
            } else {
                m_pyFuncs.Py_Finalize();
            }
        });
    }
    
    bool FinalizeWithThreadStateSwap() {
        LogDebug("Using thread state swap for finalization");
        
        return m_threadStateManager->FinalizeWithThreadState([this]() {
            // The thread state manager handles the swap
            if (m_pyFuncs.Py_FinalizeEx) {
                m_pyFuncs.Py_FinalizeEx();
            } else {
                m_pyFuncs.Py_Finalize();
            }
        });
    }
    
    bool FinalizeQueueToOriginal() {
        LogDebug("Queueing finalization to original thread");
        
        auto mainInfo = m_threadStateManager->GetThreadStateInfo(m_initializingThread);
        if (!mainInfo || !mainInfo->threadHandle) {
            return false;
        }
        
        struct FinalizationContext {
            EnhancedPythonEnvironment* env;
            std::atomic<bool> completed{false};
            std::exception_ptr exception;
        };
        
        auto context = std::make_shared<FinalizationContext>();
        context->env = this;
        
        auto apcFunc = [](ULONG_PTR param) -> void {
            auto ctx = reinterpret_cast<FinalizationContext*>(param);
            try {
                ctx->env->FinalizeSameThread();
                ctx->completed = true;
            } catch (...) {
                ctx->exception = std::current_exception();
                ctx->completed = true;
            }
        };
        
        if (!QueueUserAPC(apcFunc, mainInfo->threadHandle, 
                          reinterpret_cast<ULONG_PTR>(context.get()))) {
            return false;
        }
        
        // Wait for completion
        auto start = std::chrono::steady_clock::now();
        while (!context->completed && 
               std::chrono::steady_clock::now() - start < std::chrono::seconds(10)) {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
        
        if (context->exception) {
            try {
                std::rethrow_exception(context->exception);
            } catch (const std::exception& e) {
                LogError("Exception during finalization: " + std::string(e.what()));
            }
            return false;
        }
        
        return context->completed;
    }
    
    bool FinalizeForceWithGIL() {
        LogWarning("Forcing finalization with GIL acquisition");
        
        // Last resort - try to make it as safe as possible
        if (m_PyGILState_Ensure && m_PyGILState_Release) {
            int gilState = m_PyGILState_Ensure();
            
            // Clear any pending errors
            if (m_pyFuncs.PyErr_Clear) {
                m_pyFuncs.PyErr_Clear();
            }
            
            // Try to stop all Python threads gracefully
            if (m_pyFuncs.PyRun_SimpleString) {
                m_pyFuncs.PyRun_SimpleString(
                    "import threading\n"
                    "import time\n"
                    "for t in threading.enumerate():\n"
                    "    if t != threading.main_thread():\n"
                    "        t.join(timeout=1.0)\n"
                );
            }
            
            m_PyGILState_Release(gilState);
            
            // Give threads time to finish
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
        }
        
        // Finalize
        if (m_pyFuncs.Py_FinalizeEx) {
            int result = m_pyFuncs.Py_FinalizeEx();
            if (result < 0) {
                LogError("Py_FinalizeEx returned error");
                return false;
            }
        } else {
            m_pyFuncs.Py_Finalize();
        }
        
        return true;
    }
    
    void SetupThreadStateHooks() {
        // This could be extended to automatically capture thread state
        // when new threads first call into Python
    }
    
    std::string GetStrategyName(FinalizationStrategy strategy) {
        switch (strategy) {
            case FinalizationStrategy::SameThread: return "SameThread";
            case FinalizationStrategy::ThreadStateSwap: return "ThreadStateSwap";
            case FinalizationStrategy::QueueToOriginal: return "QueueToOriginal";
            case FinalizationStrategy::ForceWithGIL: return "ForceWithGIL";
            default: return "Unknown";
        }
    }
    
    void LogDebug(const std::string& message) {
        #ifdef _DEBUG
        std::cout << "[DEBUG] " << message << std::endl;
        #endif
    }
    
    void LogWarning(const std::string& message) {
        std::cerr << "[WARNING] " << message << std::endl;
    }
    
    void LogError(const std::string& message) {
        std::cerr << "[ERROR] " << message << std::endl;
        m_lastError = message;
    }
};

// Usage example showing thread state benefits
class ThreadStateUsageExample {
public:
    static void Demonstrate() {
        auto manager = CreatePythonEnvironmentManager();
        auto env = std::make_shared<EnhancedPythonEnvironment>(
            "C:\\Python\\envs\\test");
        
        // Initialize on main thread
        if (!env->Initialize()) {
            std::cerr << "Failed to initialize" << std::endl;
            return;
        }
        
        // Register worker threads
        std::vector<std::thread> workers;
        
        for (int i = 0; i < 3; ++i) {
            workers.emplace_back([env, i]() {
                // Register this thread for Python usage
                env->RegisterThreadForPython("Worker" + std::to_string(i));
                
                // Now can safely use Python
                env->ExecutePythonSafely([i]() {
                    auto bridge = env->GetBridge();
                    bridge->ExecuteString(
                        "import threading\n"
                        "print(f'Worker " + std::to_string(i) + 
                        " thread: {threading.current_thread().name}')"
                    );
                });
            });
        }
        
        // Wait for workers
        for (auto& t : workers) {
            t.join();
        }
        
        // Finalization will use optimal strategy based on current thread
        std::cout << "Finalization strategy: " 
                  << env->GetStrategyName(env->DetermineFinalizationStrategy()) 
                  << std::endl;
        
        // This will handle finalization optimally
        env->Shutdown();
    }
};

//=====================================
// PythonTypeConverter.h - Template-based type conversion system
#pragma once

#include "IPythonEnvironment.h"
#include <type_traits>
#include <typeindex>
#include <string>
#include <vector>
#include <map>
#include <optional>
#include <memory>
#include <complex>
#include <array>
#include <tuple>

// Forward declarations
template<typename T> struct PythonConverter;
template<typename T> struct has_python_converter;

// Base converter traits
template<typename T>
struct PythonConverterTraits {
    static constexpr bool is_registered = false;
    static constexpr const char* python_type_name = "object";
};

// SFINAE helper to detect if converter exists
template<typename T, typename = void>
struct has_python_converter : std::false_type {};

template<typename T>
struct has_python_converter<T, std::void_t<decltype(PythonConverter<T>::ToPython),
                                          decltype(PythonConverter<T>::FromPython)>> 
    : std::true_type {};

// Main converter interface
template<typename T>
struct PythonConverter {
    // These must be specialized for each type
    static PyResult ToPython(IPythonBridge* bridge, const T& value);
    static std::optional<T> FromPython(IPythonBridge* bridge, PyObjectId id);
    
    // Optional: Type checking
    static bool CheckType(IPythonBridge* bridge, PyObjectId id) {
        return FromPython(bridge, id).has_value();
    }
};

// Converter registration macro
#define REGISTER_PYTHON_CONVERTER(Type, PythonTypeName) \
    template<> \
    struct PythonConverterTraits<Type> { \
        static constexpr bool is_registered = true; \
        static constexpr const char* python_type_name = PythonTypeName; \
    };

// Basic type converters
template<>
struct PythonConverter<int> {
    static PyResult ToPython(IPythonBridge* bridge, const int& value) {
        return bridge->CreateInt(static_cast<int64_t>(value));
    }
    
    static std::optional<int> FromPython(IPythonBridge* bridge, PyObjectId id) {
        auto result = bridge->AsInt(id);
        if (result.has_value()) {
            return static_cast<int>(*result);
        }
        return std::nullopt;
    }
};
REGISTER_PYTHON_CONVERTER(int, "int")

template<>
struct PythonConverter<double> {
    static PyResult ToPython(IPythonBridge* bridge, const double& value) {
        return bridge->CreateFloat(value);
    }
    
    static std::optional<double> FromPython(IPythonBridge* bridge, PyObjectId id) {
        return bridge->AsFloat(id);
    }
};
REGISTER_PYTHON_CONVERTER(double, "float")

template<>
struct PythonConverter<std::string> {
    static PyResult ToPython(IPythonBridge* bridge, const std::string& value) {
        return bridge->CreateString(value);
    }
    
    static std::optional<std::string> FromPython(IPythonBridge* bridge, PyObjectId id) {
        return bridge->AsString(id);
    }
};
REGISTER_PYTHON_CONVERTER(std::string, "str")

template<>
struct PythonConverter<bool> {
    static PyResult ToPython(IPythonBridge* bridge, const bool& value) {
        return bridge->CreateBool(value);
    }
    
    static std::optional<bool> FromPython(IPythonBridge* bridge, PyObjectId id) {
        return bridge->AsBool(id);
    }
};
REGISTER_PYTHON_CONVERTER(bool, "bool")

// Container converters
template<typename T>
struct PythonConverter<std::vector<T>> {
    static_assert(has_python_converter<T>::value, 
                  "Element type must have a Python converter");
    
    static PyResult ToPython(IPythonBridge* bridge, const std::vector<T>& value) {
        std::vector<PyObjectId> items;
        items.reserve(value.size());
        
        for (const auto& item : value) {
            auto result = PythonConverter<T>::ToPython(bridge, item);
            if (!result.success) {
                // Clean up created objects
                for (auto id : items) {
                    bridge->ReleaseObject(id);
                }
                return result;
            }
            items.push_back(result.objectId);
        }
        
        auto listResult = bridge->CreateList(items);
        
        // Clean up temporary objects
        for (auto id : items) {
            bridge->ReleaseObject(id);
        }
        
        return listResult;
    }
    
    static std::optional<std::vector<T>> FromPython(IPythonBridge* bridge, PyObjectId id) {
        // Get list length
        auto lenResult = bridge->CallMethod(id, "__len__", {});
        if (!lenResult.success) return std::nullopt;
        
        auto length = bridge->AsInt(lenResult.objectId);
        bridge->ReleaseObject(lenResult.objectId);
        
        if (!length.has_value()) return std::nullopt;
        
        std::vector<T> result;
        result.reserve(*length);
        
        // Iterate through list
        for (int64_t i = 0; i < *length; ++i) {
            auto indexId = bridge->CreateInt(i);
            auto itemResult = bridge->GetItem(id, indexId.objectId);
            bridge->ReleaseObject(indexId.objectId);
            
            if (!itemResult.success) return std::nullopt;
            
            auto item = PythonConverter<T>::FromPython(bridge, itemResult.objectId);
            bridge->ReleaseObject(itemResult.objectId);
            
            if (!item.has_value()) return std::nullopt;
            
            result.push_back(std::move(*item));
        }
        
        return result;
    }
};

template<typename K, typename V>
struct PythonConverter<std::map<K, V>> {
    static_assert(has_python_converter<K>::value && has_python_converter<V>::value,
                  "Key and value types must have Python converters");
    
    static PyResult ToPython(IPythonBridge* bridge, const std::map<K, V>& value) {
        std::map<PyObjectId, PyObjectId> items;
        std::vector<PyObjectId> tempIds;
        
        for (const auto& [key, val] : value) {
            auto keyResult = PythonConverter<K>::ToPython(bridge, key);
            if (!keyResult.success) {
                // Clean up
                for (auto id : tempIds) {
                    bridge->ReleaseObject(id);
                }
                return keyResult;
            }
            tempIds.push_back(keyResult.objectId);
            
            auto valResult = PythonConverter<V>::ToPython(bridge, val);
            if (!valResult.success) {
                // Clean up
                for (auto id : tempIds) {
                    bridge->ReleaseObject(id);
                }
                return valResult;
            }
            tempIds.push_back(valResult.objectId);
            
            items[keyResult.objectId] = valResult.objectId;
        }
        
        auto dictResult = bridge->CreateDict(items);
        
        // Clean up temporary objects
        for (auto id : tempIds) {
            bridge->ReleaseObject(id);
        }
        
        return dictResult;
    }
    
    static std::optional<std::map<K, V>> FromPython(IPythonBridge* bridge, PyObjectId id) {
        // Get dict items
        auto itemsResult = bridge->CallMethod(id, "items", {});
        if (!itemsResult.success) return std::nullopt;
        
        // Convert items to list
        auto listResult = bridge->CallMethod(itemsResult.objectId, "__iter__", {});
        bridge->ReleaseObject(itemsResult.objectId);
        
        if (!listResult.success) return std::nullopt;
        
        std::map<K, V> result;
        
        // Iterate through items
        // This is simplified - in practice you'd need proper iteration protocol
        
        bridge->ReleaseObject(listResult.objectId);
        return result;
    }
};

// Complex number converter
template<typename T>
struct PythonConverter<std::complex<T>> {
    static_assert(std::is_floating_point<T>::value, 
                  "Complex numbers require floating point type");
    
    static PyResult ToPython(IPythonBridge* bridge, const std::complex<T>& value) {
        // Create Python complex number
        auto realResult = bridge->CreateFloat(value.real());
        auto imagResult = bridge->CreateFloat(value.imag());
        
        auto complexResult = bridge->CallMethod(
            bridge->GetObject("complex").objectId, 
            "__call__", 
            {realResult.objectId, imagResult.objectId}
        );
        
        bridge->ReleaseObject(realResult.objectId);
        bridge->ReleaseObject(imagResult.objectId);
        
        return complexResult;
    }
    
    static std::optional<std::complex<T>> FromPython(IPythonBridge* bridge, PyObjectId id) {
        auto realResult = bridge->GetAttribute(id, "real");
        auto imagResult = bridge->GetAttribute(id, "imag");
        
        if (!realResult.success || !imagResult.success) {
            if (realResult.success) bridge->ReleaseObject(realResult.objectId);
            if (imagResult.success) bridge->ReleaseObject(imagResult.objectId);
            return std::nullopt;
        }
        
        auto real = bridge->AsFloat(realResult.objectId);
        auto imag = bridge->AsFloat(imagResult.objectId);
        
        bridge->ReleaseObject(realResult.objectId);
        bridge->ReleaseObject(imagResult.objectId);
        
        if (real.has_value() && imag.has_value()) {
            return std::complex<T>(static_cast<T>(*real), static_cast<T>(*imag));
        }
        
        return std::nullopt;
    }
};
REGISTER_PYTHON_CONVERTER(std::complex<float>, "complex")
REGISTER_PYTHON_CONVERTER(std::complex<double>, "complex")

// Optional converter
template<typename T>
struct PythonConverter<std::optional<T>> {
    static_assert(has_python_converter<T>::value,
                  "Optional type must have a Python converter");
    
    static PyResult ToPython(IPythonBridge* bridge, const std::optional<T>& value) {
        if (value.has_value()) {
            return PythonConverter<T>::ToPython(bridge, *value);
        } else {
            // Return None
            auto noneResult = bridge->GetObject("None");
            return noneResult;
        }
    }
    
    static std::optional<std::optional<T>> FromPython(IPythonBridge* bridge, PyObjectId id) {
        // Check if None
        auto noneResult = bridge->GetObject("None");
        auto isNoneResult = bridge->CallMethod(id, "__eq__", {noneResult.objectId});
        bridge->ReleaseObject(noneResult.objectId);
        
        if (!isNoneResult.success) return std::nullopt;
        
        auto isNone = bridge->AsBool(isNoneResult.objectId);
        bridge->ReleaseObject(isNoneResult.objectId);
        
        if (isNone.has_value() && *isNone) {
            return std::optional<T>(std::nullopt);
        }
        
        auto value = PythonConverter<T>::FromPython(bridge, id);
        if (value.has_value()) {
            return std::optional<T>(*value);
        }
        
        return std::nullopt;
    }
};

// Tuple converter (example for pair)
template<typename T1, typename T2>
struct PythonConverter<std::pair<T1, T2>> {
    static_assert(has_python_converter<T1>::value && has_python_converter<T2>::value,
                  "Pair types must have Python converters");
    
    static PyResult ToPython(IPythonBridge* bridge, const std::pair<T1, T2>& value) {
        auto first = PythonConverter<T1>::ToPython(bridge, value.first);
        if (!first.success) return first;
        
        auto second = PythonConverter<T2>::ToPython(bridge, value.second);
        if (!second.success) {
            bridge->ReleaseObject(first.objectId);
            return second;
        }
        
        auto tupleResult = bridge->CallMethod(
            bridge->GetObject("tuple").objectId,
            "__call__",
            {bridge->CreateList({first.objectId, second.objectId}).objectId}
        );
        
        bridge->ReleaseObject(first.objectId);
        bridge->ReleaseObject(second.objectId);
        
        return tupleResult;
    }
    
    static std::optional<std::pair<T1, T2>> FromPython(IPythonBridge* bridge, PyObjectId id) {
        auto index0 = bridge->CreateInt(0);
        auto index1 = bridge->CreateInt(1);
        
        auto first = bridge->GetItem(id, index0.objectId);
        auto second = bridge->GetItem(id, index1.objectId);
        
        bridge->ReleaseObject(index0.objectId);
        bridge->ReleaseObject(index1.objectId);
        
        if (!first.success || !second.success) {
            if (first.success) bridge->ReleaseObject(first.objectId);
            if (second.success) bridge->ReleaseObject(second.objectId);
            return std::nullopt;
        }
        
        auto val1 = PythonConverter<T1>::FromPython(bridge, first.objectId);
        auto val2 = PythonConverter<T2>::FromPython(bridge, second.objectId);
        
        bridge->ReleaseObject(first.objectId);
        bridge->ReleaseObject(second.objectId);
        
        if (val1.has_value() && val2.has_value()) {
            return std::make_pair(*val1, *val2);
        }
        
        return std::nullopt;
    }
};

// Smart pointer converter
template<typename T>
struct PythonConverter<std::shared_ptr<T>> {
    static_assert(has_python_converter<T>::value,
                  "Pointed type must have a Python converter");
    
    static PyResult ToPython(IPythonBridge* bridge, const std::shared_ptr<T>& value) {
        if (value) {
            return PythonConverter<T>::ToPython(bridge, *value);
        } else {
            return bridge->GetObject("None");
        }
    }
    
    static std::optional<std::shared_ptr<T>> FromPython(IPythonBridge* bridge, PyObjectId id) {
        // Check if None
        auto noneResult = bridge->GetObject("None");
        auto isNoneResult = bridge->CallMethod(id, "__eq__", {noneResult.objectId});
        bridge->ReleaseObject(noneResult.objectId);
        
        if (!isNoneResult.success) return std::nullopt;
        
        auto isNone = bridge->AsBool(isNoneResult.objectId);
        bridge->ReleaseObject(isNoneResult.objectId);
        
        if (isNone.has_value() && *isNone) {
            return std::shared_ptr<T>(nullptr);
        }
        
        auto value = PythonConverter<T>::FromPython(bridge, id);
        if (value.has_value()) {
            return std::make_shared<T>(std::move(*value));
        }
        
        return std::nullopt;
    }
};
//=======================================
// PythonTypeConverter.h - Template-based type conversion system
#pragma once

#include "IPythonEnvironment.h"
#include <type_traits>
#include <typeindex>
#include <string>
#include <vector>
#include <map>
#include <optional>
#include <memory>
#include <complex>
#include <array>
#include <tuple>

// Forward declarations
template<typename T> struct PythonConverter;
template<typename T> struct has_python_converter;

// Base converter traits
template<typename T>
struct PythonConverterTraits {
    static constexpr bool is_registered = false;
    static constexpr const char* python_type_name = "object";
};

// SFINAE helper to detect if converter exists
template<typename T, typename = void>
struct has_python_converter : std::false_type {};

template<typename T>
struct has_python_converter<T, std::void_t<decltype(PythonConverter<T>::ToPython),
                                          decltype(PythonConverter<T>::FromPython)>> 
    : std::true_type {};

// Main converter interface
template<typename T>
struct PythonConverter {
    // These must be specialized for each type
    static PyResult ToPython(IPythonBridge* bridge, const T& value);
    static std::optional<T> FromPython(IPythonBridge* bridge, PyObjectId id);
    
    // Optional: Type checking
    static bool CheckType(IPythonBridge* bridge, PyObjectId id) {
        return FromPython(bridge, id).has_value();
    }
};

// Converter registration macro
#define REGISTER_PYTHON_CONVERTER(Type, PythonTypeName) \
    template<> \
    struct PythonConverterTraits<Type> { \
        static constexpr bool is_registered = true; \
        static constexpr const char* python_type_name = PythonTypeName; \
    };

// Basic type converters
template<>
struct PythonConverter<int> {
    static PyResult ToPython(IPythonBridge* bridge, const int& value) {
        return bridge->CreateInt(static_cast<int64_t>(value));
    }
    
    static std::optional<int> FromPython(IPythonBridge* bridge, PyObjectId id) {
        auto result = bridge->AsInt(id);
        if (result.has_value()) {
            return static_cast<int>(*result);
        }
        return std::nullopt;
    }
};
REGISTER_PYTHON_CONVERTER(int, "int")

template<>
struct PythonConverter<double> {
    static PyResult ToPython(IPythonBridge* bridge, const double& value) {
        return bridge->CreateFloat(value);
    }
    
    static std::optional<double> FromPython(IPythonBridge* bridge, PyObjectId id) {
        return bridge->AsFloat(id);
    }
};
REGISTER_PYTHON_CONVERTER(double, "float")

template<>
struct PythonConverter<std::string> {
    static PyResult ToPython(IPythonBridge* bridge, const std::string& value) {
        return bridge->CreateString(value);
    }
    
    static std::optional<std::string> FromPython(IPythonBridge* bridge, PyObjectId id) {
        return bridge->AsString(id);
    }
};
REGISTER_PYTHON_CONVERTER(std::string, "str")

template<>
struct PythonConverter<bool> {
    static PyResult ToPython(IPythonBridge* bridge, const bool& value) {
        return bridge->CreateBool(value);
    }
    
    static std::optional<bool> FromPython(IPythonBridge* bridge, PyObjectId id) {
        return bridge->AsBool(id);
    }
};
REGISTER_PYTHON_CONVERTER(bool, "bool")

// Container converters
template<typename T>
struct PythonConverter<std::vector<T>> {
    static_assert(has_python_converter<T>::value, 
                  "Element type must have a Python converter");
    
    static PyResult ToPython(IPythonBridge* bridge, const std::vector<T>& value) {
        std::vector<PyObjectId> items;
        items.reserve(value.size());
        
        for (const auto& item : value) {
            auto result = PythonConverter<T>::ToPython(bridge, item);
            if (!result.success) {
                // Clean up created objects
                for (auto id : items) {
                    bridge->ReleaseObject(id);
                }
                return result;
            }
            items.push_back(result.objectId);
        }
        
        auto listResult = bridge->CreateList(items);
        
        // Clean up temporary objects
        for (auto id : items) {
            bridge->ReleaseObject(id);
        }
        
        return listResult;
    }
    
    static std::optional<std::vector<T>> FromPython(IPythonBridge* bridge, PyObjectId id) {
        // Get list length
        auto lenResult = bridge->CallMethod(id, "__len__", {});
        if (!lenResult.success) return std::nullopt;
        
        auto length = bridge->AsInt(lenResult.objectId);
        bridge->ReleaseObject(lenResult.objectId);
        
        if (!length.has_value()) return std::nullopt;
        
        std::vector<T> result;
        result.reserve(*length);
        
        // Iterate through list
        for (int64_t i = 0; i < *length; ++i) {
            auto indexId = bridge->CreateInt(i);
            auto itemResult = bridge->GetItem(id, indexId.objectId);
            bridge->ReleaseObject(indexId.objectId);
            
            if (!itemResult.success) return std::nullopt;
            
            auto item = PythonConverter<T>::FromPython(bridge, itemResult.objectId);
            bridge->ReleaseObject(itemResult.objectId);
            
            if (!item.has_value()) return std::nullopt;
            
            result.push_back(std::move(*item));
        }
        
        return result;
    }
};

template<typename K, typename V>
struct PythonConverter<std::map<K, V>> {
    static_assert(has_python_converter<K>::value && has_python_converter<V>::value,
                  "Key and value types must have Python converters");
    
    static PyResult ToPython(IPythonBridge* bridge, const std::map<K, V>& value) {
        std::map<PyObjectId, PyObjectId> items;
        std::vector<PyObjectId> tempIds;
        
        for (const auto& [key, val] : value) {
            auto keyResult = PythonConverter<K>::ToPython(bridge, key);
            if (!keyResult.success) {
                // Clean up
                for (auto id : tempIds) {
                    bridge->ReleaseObject(id);
                }
                return keyResult;
            }
            tempIds.push_back(keyResult.objectId);
            
            auto valResult = PythonConverter<V>::ToPython(bridge, val);
            if (!valResult.success) {
                // Clean up
                for (auto id : tempIds) {
                    bridge->ReleaseObject(id);
                }
                return valResult;
            }
            tempIds.push_back(valResult.objectId);
            
            items[keyResult.objectId] = valResult.objectId;
        }
        
        auto dictResult = bridge->CreateDict(items);
        
        // Clean up temporary objects
        for (auto id : tempIds) {
            bridge->ReleaseObject(id);
        }
        
        return dictResult;
    }
    
    static std::optional<std::map<K, V>> FromPython(IPythonBridge* bridge, PyObjectId id) {
        // Get dict items
        auto itemsResult = bridge->CallMethod(id, "items", {});
        if (!itemsResult.success) return std::nullopt;
        
        // Convert items to list
        auto listResult = bridge->CallMethod(itemsResult.objectId, "__iter__", {});
        bridge->ReleaseObject(itemsResult.objectId);
        
        if (!listResult.success) return std::nullopt;
        
        std::map<K, V> result;
        
        // Iterate through items
        // This is simplified - in practice you'd need proper iteration protocol
        
        bridge->ReleaseObject(listResult.objectId);
        return result;
    }
};

// Complex number converter
template<typename T>
struct PythonConverter<std::complex<T>> {
    static_assert(std::is_floating_point<T>::value, 
                  "Complex numbers require floating point type");
    
    static PyResult ToPython(IPythonBridge* bridge, const std::complex<T>& value) {
        // Create Python complex number
        auto realResult = bridge->CreateFloat(value.real());
        auto imagResult = bridge->CreateFloat(value.imag());
        
        auto complexResult = bridge->CallMethod(
            bridge->GetObject("complex").objectId, 
            "__call__", 
            {realResult.objectId, imagResult.objectId}
        );
        
        bridge->ReleaseObject(realResult.objectId);
        bridge->ReleaseObject(imagResult.objectId);
        
        return complexResult;
    }
    
    static std::optional<std::complex<T>> FromPython(IPythonBridge* bridge, PyObjectId id) {
        auto realResult = bridge->GetAttribute(id, "real");
        auto imagResult = bridge->GetAttribute(id, "imag");
        
        if (!realResult.success || !imagResult.success) {
            if (realResult.success) bridge->ReleaseObject(realResult.objectId);
            if (imagResult.success) bridge->ReleaseObject(imagResult.objectId);
            return std::nullopt;
        }
        
        auto real = bridge->AsFloat(realResult.objectId);
        auto imag = bridge->AsFloat(imagResult.objectId);
        
        bridge->ReleaseObject(realResult.objectId);
        bridge->ReleaseObject(imagResult.objectId);
        
        if (real.has_value() && imag.has_value()) {
            return std::complex<T>(static_cast<T>(*real), static_cast<T>(*imag));
        }
        
        return std::nullopt;
    }
};
REGISTER_PYTHON_CONVERTER(std::complex<float>, "complex")
REGISTER_PYTHON_CONVERTER(std::complex<double>, "complex")

// Optional converter
template<typename T>
struct PythonConverter<std::optional<T>> {
    static_assert(has_python_converter<T>::value,
                  "Optional type must have a Python converter");
    
    static PyResult ToPython(IPythonBridge* bridge, const std::optional<T>& value) {
        if (value.has_value()) {
            return PythonConverter<T>::ToPython(bridge, *value);
        } else {
            // Return None
            auto noneResult = bridge->GetObject("None");
            return noneResult;
        }
    }
    
    static std::optional<std::optional<T>> FromPython(IPythonBridge* bridge, PyObjectId id) {
        // Check if None
        auto noneResult = bridge->GetObject("None");
        auto isNoneResult = bridge->CallMethod(id, "__eq__", {noneResult.objectId});
        bridge->ReleaseObject(noneResult.objectId);
        
        if (!isNoneResult.success) return std::nullopt;
        
        auto isNone = bridge->AsBool(isNoneResult.objectId);
        bridge->ReleaseObject(isNoneResult.objectId);
        
        if (isNone.has_value() && *isNone) {
            return std::optional<T>(std::nullopt);
        }
        
        auto value = PythonConverter<T>::FromPython(bridge, id);
        if (value.has_value()) {
            return std::optional<T>(*value);
        }
        
        return std::nullopt;
    }
};

// Tuple converter (example for pair)
template<typename T1, typename T2>
struct PythonConverter<std::pair<T1, T2>> {
    static_assert(has_python_converter<T1>::value && has_python_converter<T2>::value,
                  "Pair types must have Python converters");
    
    static PyResult ToPython(IPythonBridge* bridge, const std::pair<T1, T2>& value) {
        auto first = PythonConverter<T1>::ToPython(bridge, value.first);
        if (!first.success) return first;
        
        auto second = PythonConverter<T2>::ToPython(bridge, value.second);
        if (!second.success) {
            bridge->ReleaseObject(first.objectId);
            return second;
        }
        
        auto tupleResult = bridge->CallMethod(
            bridge->GetObject("tuple").objectId,
            "__call__",
            {bridge->CreateList({first.objectId, second.objectId}).objectId}
        );
        
        bridge->ReleaseObject(first.objectId);
        bridge->ReleaseObject(second.objectId);
        
        return tupleResult;
    }
    
    static std::optional<std::pair<T1, T2>> FromPython(IPythonBridge* bridge, PyObjectId id) {
        auto index0 = bridge->CreateInt(0);
        auto index1 = bridge->CreateInt(1);
        
        auto first = bridge->GetItem(id, index0.objectId);
        auto second = bridge->GetItem(id, index1.objectId);
        
        bridge->ReleaseObject(index0.objectId);
        bridge->ReleaseObject(index1.objectId);
        
        if (!first.success || !second.success) {
            if (first.success) bridge->ReleaseObject(first.objectId);
            if (second.success) bridge->ReleaseObject(second.objectId);
            return std::nullopt;
        }
        
        auto val1 = PythonConverter<T1>::FromPython(bridge, first.objectId);
        auto val2 = PythonConverter<T2>::FromPython(bridge, second.objectId);
        
        bridge->ReleaseObject(first.objectId);
        bridge->ReleaseObject(second.objectId);
        
        if (val1.has_value() && val2.has_value()) {
            return std::make_pair(*val1, *val2);
        }
        
        return std::nullopt;
    }
};

// Smart pointer converter
template<typename T>
struct PythonConverter<std::shared_ptr<T>> {
    static_assert(has_python_converter<T>::value,
                  "Pointed type must have a Python converter");
    
    static PyResult ToPython(IPythonBridge* bridge, const std::shared_ptr<T>& value) {
        if (value) {
            return PythonConverter<T>::ToPython(bridge, *value);
        } else {
            return bridge->GetObject("None");
        }
    }
    
    static std::optional<std::shared_ptr<T>> FromPython(IPythonBridge* bridge, PyObjectId id) {
        // Check if None
        auto noneResult = bridge->GetObject("None");
        auto isNoneResult = bridge->CallMethod(id, "__eq__", {noneResult.objectId});
        bridge->ReleaseObject(noneResult.objectId);
        
        if (!isNoneResult.success) return std::nullopt;
        
        auto isNone = bridge->AsBool(isNoneResult.objectId);
        bridge->ReleaseObject(isNoneResult.objectId);
        
        if (isNone.has_value() && *isNone) {
            return std::shared_ptr<T>(nullptr);
        }
        
        auto value = PythonConverter<T>::FromPython(bridge, id);
        if (value.has_value()) {
            return std::make_shared<T>(std::move(*value));
        }
        
        return std::nullopt;
    }
};

//==================================================
// PythonCustomConverters.h - Examples of custom type converters
#pragma once

#include "PythonTypeConverter.h"
#include <chrono>
#include <filesystem>
#include <variant>
#include <Eigen/Core>  // Example with Eigen library

// Example 1: Custom Point class
struct Point3D {
    double x, y, z;
    
    Point3D(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) {}
};

template<>
struct PythonConverter<Point3D> {
    static PyResult ToPython(IPythonBridge* bridge, const Point3D& point) {
        // Create a Python dict: {'x': x, 'y': y, 'z': z}
        auto xKey = bridge->CreateString("x");
        auto yKey = bridge->CreateString("y");
        auto zKey = bridge->CreateString("z");
        
        auto xVal = bridge->CreateFloat(point.x);
        auto yVal = bridge->CreateFloat(point.y);
        auto zVal = bridge->CreateFloat(point.z);
        
        std::map<PyObjectId, PyObjectId> items = {
            {xKey.objectId, xVal.objectId},
            {yKey.objectId, yVal.objectId},
            {zKey.objectId, zVal.objectId}
        };
        
        auto result = bridge->CreateDict(items);
        
        // Clean up
        bridge->ReleaseObject(xKey.objectId);
        bridge->ReleaseObject(yKey.objectId);
        bridge->ReleaseObject(zKey.objectId);
        bridge->ReleaseObject(xVal.objectId);
        bridge->ReleaseObject(yVal.objectId);
        bridge->ReleaseObject(zVal.objectId);
        
        return result;
    }
    
    static std::optional<Point3D> FromPython(IPythonBridge* bridge, PyObjectId id) {
        auto xKey = bridge->CreateString("x");
        auto yKey = bridge->CreateString("y");
        auto zKey = bridge->CreateString("z");
        
        auto xResult = bridge->GetItem(id, xKey.objectId);
        auto yResult = bridge->GetItem(id, yKey.objectId);
        auto zResult = bridge->GetItem(id, zKey.objectId);
        
        bridge->ReleaseObject(xKey.objectId);
        bridge->ReleaseObject(yKey.objectId);
        bridge->ReleaseObject(zKey.objectId);
        
        if (!xResult.success || !yResult.success || !zResult.success) {
            if (xResult.success) bridge->ReleaseObject(xResult.objectId);
            if (yResult.success) bridge->ReleaseObject(yResult.objectId);
            if (zResult.success) bridge->ReleaseObject(zResult.objectId);
            return std::nullopt;
        }
        
        auto x = bridge->AsFloat(xResult.objectId);
        auto y = bridge->AsFloat(yResult.objectId);
        auto z = bridge->AsFloat(zResult.objectId);
        
        bridge->ReleaseObject(xResult.objectId);
        bridge->ReleaseObject(yResult.objectId);
        bridge->ReleaseObject(zResult.objectId);
        
        if (x.has_value() && y.has_value() && z.has_value()) {
            return Point3D(*x, *y, *z);
        }
        
        return std::nullopt;
    }
    
    static bool CheckType(IPythonBridge* bridge, PyObjectId id) {
        // Check if it's a dict with x, y, z keys
        auto typeResult = bridge->CallMethod(
            bridge->GetObject("type").objectId, 
            "__call__", 
            {id}
        );
        
        if (!typeResult.success) return false;
        
        auto dictType = bridge->GetObject("dict");
        auto isDict = bridge->CallMethod(
            typeResult.objectId, 
            "__eq__", 
            {dictType.objectId}
        );
        
        bridge->ReleaseObject(typeResult.objectId);
        bridge->ReleaseObject(dictType.objectId);
        
        if (!isDict.success) return false;
        
        auto result = bridge->AsBool(isDict.objectId);
        bridge->ReleaseObject(isDict.objectId);
        
        return result.has_value() && *result;
    }
};
REGISTER_PYTHON_CONVERTER(Point3D, "dict")

// Example 2: std::chrono time_point converter
template<>
struct PythonConverter<std::chrono::system_clock::time_point> {
    static PyResult ToPython(IPythonBridge* bridge, const std::chrono::system_clock::time_point& tp) {
        // Convert to Python datetime
        auto duration = tp.time_since_epoch();
        auto seconds = std::chrono::duration_cast<std::chrono::seconds>(duration).count();
        
        // Import datetime module
        auto datetimeModule = bridge->ImportModule("datetime");
        if (!datetimeModule.success) return datetimeModule;
        
        // Call datetime.datetime.fromtimestamp(seconds)
        auto fromtimestamp = bridge->GetAttribute(
            datetimeModule.objectId, 
            "datetime.fromtimestamp"
        );
        
        bridge->ReleaseObject(datetimeModule.objectId);
        
        if (!fromtimestamp.success) return fromtimestamp;
        
        auto secondsObj = bridge->CreateFloat(static_cast<double>(seconds));
        auto result = bridge->CallMethod(
            fromtimestamp.objectId, 
            "__call__", 
            {secondsObj.objectId}
        );
        
        bridge->ReleaseObject(fromtimestamp.objectId);
        bridge->ReleaseObject(secondsObj.objectId);
        
        return result;
    }
    
    static std::optional<std::chrono::system_clock::time_point> FromPython(
        IPythonBridge* bridge, PyObjectId id) {
        
        // Call timestamp() method
        auto timestampResult = bridge->CallMethod(id, "timestamp", {});
        if (!timestampResult.success) return std::nullopt;
        
        auto timestamp = bridge->AsFloat(timestampResult.objectId);
        bridge->ReleaseObject(timestampResult.objectId);
        
        if (timestamp.has_value()) {
            auto seconds = std::chrono::seconds(static_cast<int64_t>(*timestamp));
            return std::chrono::system_clock::time_point(seconds);
        }
        
        return std::nullopt;
    }
};
REGISTER_PYTHON_CONVERTER(std::chrono::system_clock::time_point, "datetime")

// Example 3: std::filesystem::path converter
template<>
struct PythonConverter<std::filesystem::path> {
    static PyResult ToPython(IPythonBridge* bridge, const std::filesystem::path& path) {
        // Convert to Python Path object
        auto pathlibModule = bridge->ImportModule("pathlib");
        if (!pathlibModule.success) return pathlibModule;
        
        auto pathClass = bridge->GetAttribute(pathlibModule.objectId, "Path");
        bridge->ReleaseObject(pathlibModule.objectId);
        
        if (!pathClass.success) return pathClass;
        
        auto pathStr = bridge->CreateString(path.string());
        auto result = bridge->CallMethod(
            pathClass.objectId, 
            "__call__", 
            {pathStr.objectId}
        );
        
        bridge->ReleaseObject(pathClass.objectId);
        bridge->ReleaseObject(pathStr.objectId);
        
        return result;
    }
    
    static std::optional<std::filesystem::path> FromPython(IPythonBridge* bridge, PyObjectId id) {
        // Convert Path object to string
        auto strResult = bridge->CallMethod(id, "__str__", {});
        if (!strResult.success) return std::nullopt;
        
        auto pathStr = bridge->AsString(strResult.objectId);
        bridge->ReleaseObject(strResult.objectId);
        
        if (pathStr.has_value()) {
            return std::filesystem::path(*pathStr);
        }
        
        return std::nullopt;
    }
};
REGISTER_PYTHON_CONVERTER(std::filesystem::path, "Path")

// Example 4: std::variant converter
template<typename... Types>
struct PythonConverter<std::variant<Types...>> {
    static_assert((has_python_converter<Types>::value && ...), 
                  "All variant types must have Python converters");
    
    static PyResult ToPython(IPythonBridge* bridge, const std::variant<Types...>& value) {
        return std::visit([bridge](const auto& v) {
            return PythonConverter<std::decay_t<decltype(v)>>::ToPython(bridge, v);
        }, value);
    }
    
    static std::optional<std::variant<Types...>> FromPython(IPythonBridge* bridge, PyObjectId id) {
        // Try each type in order
        return TryConvert<0, Types...>(bridge, id);
    }
    
private:
    template<size_t I, typename First, typename... Rest>
    static std::optional<std::variant<Types...>> TryConvert(IPythonBridge* bridge, PyObjectId id) {
        auto result = PythonConverter<First>::FromPython(bridge, id);
        if (result.has_value()) {
            return std::variant<Types...>(std::in_place_index<I>, std::move(*result));
        }
        
        if constexpr (sizeof...(Rest) > 0) {
            return TryConvert<I + 1, Rest...>(bridge, id);
        } else {
            return std::nullopt;
        }
    }
};

// Example 5: Eigen matrix converter
#ifdef EIGEN_CORE_H
template<typename Scalar, int Rows, int Cols>
struct PythonConverter<Eigen::Matrix<Scalar, Rows, Cols>> {
    using MatrixType = Eigen::Matrix<Scalar, Rows, Cols>;
    
    static PyResult ToPython(IPythonBridge* bridge, const MatrixType& matrix) {
        // Import numpy
        auto numpyModule = bridge->ImportModule("numpy");
        if (!numpyModule.success) return numpyModule;
        
        // Create nested list
        std::vector<PyObjectId> rows;
        for (int i = 0; i < matrix.rows(); ++i) {
            std::vector<PyObjectId> row;
            for (int j = 0; j < matrix.cols(); ++j) {
                auto val = bridge->CreateFloat(matrix(i, j));
                row.push_back(val.objectId);
            }
            auto rowList = bridge->CreateList(row);
            rows.push_back(rowList.objectId);
            
            // Clean up row elements
            for (auto id : row) {
                bridge->ReleaseObject(id);
            }
        }
        
        auto listResult = bridge->CreateList(rows);
        
        // Convert to numpy array
        auto arrayFunc = bridge->GetAttribute(numpyModule.objectId, "array");
        auto result = bridge->CallMethod(
            arrayFunc.objectId, 
            "__call__", 
            {listResult.objectId}
        );
        
        // Clean up
        bridge->ReleaseObject(numpyModule.objectId);
        bridge->ReleaseObject(arrayFunc.objectId);
        bridge->ReleaseObject(listResult.objectId);
        for (auto id : rows) {
            bridge->ReleaseObject(id);
        }
        
        return result;
    }
    
    static std::optional<MatrixType> FromPython(IPythonBridge* bridge, PyObjectId id) {
        // Get shape
        auto shapeResult = bridge->GetAttribute(id, "shape");
        if (!shapeResult.success) return std::nullopt;
        
        // Convert to list
        auto tolistResult = bridge->CallMethod(id, "tolist", {});
        bridge->ReleaseObject(shapeResult.objectId);
        
        if (!tolistResult.success) return std::nullopt;
        
        // Parse nested list
        auto data = PythonConverter<std::vector<std::vector<Scalar>>>::FromPython(
            bridge, tolistResult.objectId
        );
        
        bridge->ReleaseObject(tolistResult.objectId);
        
        if (!data.has_value()) return std::nullopt;
        
        // Create matrix
        if constexpr (Rows == Eigen::Dynamic || Cols == Eigen::Dynamic) {
            int rows = data->size();
            int cols = rows > 0 ? (*data)[0].size() : 0;
            
            MatrixType matrix(rows, cols);
            for (int i = 0; i < rows; ++i) {
                for (int j = 0; j < cols; ++j) {
                    matrix(i, j) = (*data)[i][j];
                }
            }
            return matrix;
        } else {
            MatrixType matrix;
            for (int i = 0; i < Rows; ++i) {
                for (int j = 0; j < Cols; ++j) {
                    matrix(i, j) = (*data)[i][j];
                }
            }
            return matrix;
        }
    }
};
REGISTER_PYTHON_CONVERTER(Eigen::MatrixXd, "ndarray")
#endif

// Macro for easy custom type registration
#define DEFINE_PYTHON_CONVERTER_CLASS(ClassName, PythonClassName, ...) \
    template<> \
    struct PythonConverter<ClassName> { \
        static PyResult ToPython(IPythonBridge* bridge, const ClassName& obj) { \
            auto module = bridge->ImportModule("builtins"); \
            auto cls = bridge->GetAttribute(module.objectId, PythonClassName); \
            bridge->ReleaseObject(module.objectId); \
            \
            std::vector<PyObjectId> args = { __VA_ARGS__ }; \
            auto result = bridge->CreateObject(PythonClassName, args); \
            \
            for (auto id : args) { \
                bridge->ReleaseObject(id); \
            } \
            \
            return result; \
        } \
        \
        static std::optional<ClassName> FromPython(IPythonBridge* bridge, PyObjectId id) { \
            /* Custom implementation */ \
            return std::nullopt; \
        } \
    }; \
    REGISTER_PYTHON_CONVERTER(ClassName, PythonClassName)
//==============+++=======

// EnhancedPythonBridge.h - Python bridge with automatic type conversion
#pragma once

#include "IPythonEnvironment.h"
#include "PythonTypeConverter.h"
#include <functional>
#include <tuple>

// Enhanced bridge interface with type conversion
class IEnhancedPythonBridge : public IPythonBridge {
public:
    // Type-safe execution with automatic conversion
    template<typename T>
    std::optional<T> Execute(const std::string& code) {
        auto result = ExecuteString(code);
        if (!result.success) return std::nullopt;
        
        if (result.objectId == INVALID_OBJECT_ID) {
            return std::nullopt;
        }
        
        auto value = PythonConverter<T>::FromPython(this, result.objectId);
        ReleaseObject(result.objectId);
        
        return value;
    }
    
    // Type-safe variable access
    template<typename T>
    std::optional<T> GetVariable(const std::string& name) {
        auto result = GetObject(name);
        if (!result.success) return std::nullopt;
        
        auto value = PythonConverter<T>::FromPython(this, result.objectId);
        ReleaseObject(result.objectId);
        
        return value;
    }
    
    // Type-safe variable setting
    template<typename T>
    bool SetVariable(const std::string& name, const T& value) {
        auto pyResult = PythonConverter<T>::ToPython(this, value);
        if (!pyResult.success) return false;
        
        auto result = SetObject(name, pyResult.objectId);
        ReleaseObject(pyResult.objectId);
        
        return result.success;
    }
    
    // Call function with type-safe arguments and return
    template<typename Return, typename... Args>
    std::optional<Return> CallFunction(const std::string& module, 
                                      const std::string& function,
                                      Args&&... args) {
        // Import module
        auto moduleResult = ImportModule(module);
        if (!moduleResult.success) return std::nullopt;
        
        // Get function
        auto funcResult = GetAttribute(moduleResult.objectId, function);
        ReleaseObject(moduleResult.objectId);
        
        if (!funcResult.success) return std::nullopt;
        
        // Convert arguments
        std::vector<PyObjectId> argIds;
        if (!ConvertArgs(argIds, std::forward<Args>(args)...)) {
            ReleaseObject(funcResult.objectId);
            for (auto id : argIds) ReleaseObject(id);
            return std::nullopt;
        }
        
        // Call function
        auto result = CallMethod(funcResult.objectId, "__call__", argIds);
        
        // Clean up
        ReleaseObject(funcResult.objectId);
        for (auto id : argIds) ReleaseObject(id);
        
        if (!result.success) return std::nullopt;
        
        // Convert result
        auto value = PythonConverter<Return>::FromPython(this, result.objectId);
        ReleaseObject(result.objectId);
        
        return value;
    }
    
    // Create Python object from C++ type
    template<typename T>
    PyObjectId CreateFrom(const T& value) {
        auto result = PythonConverter<T>::ToPython(this, value);
        return result.success ? result.objectId : INVALID_OBJECT_ID;
    }
    
    // Extract C++ type from Python object
    template<typename T>
    std::optional<T> ExtractAs(PyObjectId id) {
        return PythonConverter<T>::FromPython(this, id);
    }
    
    // Check if Python object can be converted to C++ type
    template<typename T>
    bool CanConvertTo(PyObjectId id) {
        return PythonConverter<T>::CheckType(this, id);
    }
    
    // Execute Python code and get multiple return values
    template<typename... Types>
    std::optional<std::tuple<Types...>> ExecuteMultiple(const std::string& code) {
        auto result = ExecuteString(code);
        if (!result.success) return std::nullopt;
        
        if (result.objectId == INVALID_OBJECT_ID) {
            return std::nullopt;
        }
        
        // Assume result is a tuple
        auto tuple = ExtractTuple<Types...>(result.objectId, std::index_sequence_for<Types...>{});
        ReleaseObject(result.objectId);
        
        return tuple;
    }
    
    // RAII helper for Python objects
    class PyObjectRef {
    private:
        IEnhancedPythonBridge* m_bridge;
        PyObjectId m_id;
        
    public:
        PyObjectRef(IEnhancedPythonBridge* bridge, PyObjectId id) 
            : m_bridge(bridge), m_id(id) {}
        
        ~PyObjectRef() {
            if (m_id != INVALID_OBJECT_ID) {
                m_bridge->ReleaseObject(m_id);
            }
        }
        
        PyObjectRef(PyObjectRef&& other) noexcept 
            : m_bridge(other.m_bridge), m_id(other.m_id) {
            other.m_id = INVALID_OBJECT_ID;
        }
        
        PyObjectId get() const { return m_id; }
        
        template<typename T>
        std::optional<T> as() const {
            return m_bridge->ExtractAs<T>(m_id);
        }
        
        PyObjectRef(const PyObjectRef&) = delete;
        PyObjectRef& operator=(const PyObjectRef&) = delete;
    };
    
    // Create RAII wrapper
    PyObjectRef MakeRef(PyObjectId id) {
        return PyObjectRef(this, id);
    }
    
private:
    // Helper for converting argument pack
    template<typename... Args>
    bool ConvertArgs(std::vector<PyObjectId>& ids, Args&&... args) {
        return ConvertArgsImpl(ids, std::forward<Args>(args)...);
    }
    
    bool ConvertArgsImpl(std::vector<PyObjectId>& ids) {
        return true;
    }
    
    template<typename First, typename... Rest>
    bool ConvertArgsImpl(std::vector<PyObjectId>& ids, First&& first, Rest&&... rest) {
        auto result = PythonConverter<std::decay_t<First>>::ToPython(this, first);
        if (!result.success) return false;
        
        ids.push_back(result.objectId);
        return ConvertArgsImpl(ids, std::forward<Rest>(rest)...);
    }
    
    // Helper for extracting tuple
    template<typename... Types, size_t... Is>
    std::optional<std::tuple<Types...>> ExtractTuple(PyObjectId tupleId, 
                                                     std::index_sequence<Is...>) {
        std::tuple<std::optional<Types>...> values;
        
        ((std::get<Is>(values) = ExtractTupleElement<Types>(tupleId, Is)), ...);
        
        if ((std::get<Is>(values).has_value() && ...)) {
            return std::make_tuple(*std::get<Is>(values)...);
        }
        
        return std::nullopt;
    }
    
    template<typename T>
    std::optional<T> ExtractTupleElement(PyObjectId tupleId, size_t index) {
        auto indexId = CreateInt(index);
        auto elemResult = GetItem(tupleId, indexId);
        ReleaseObject(indexId);
        
        if (!elemResult.success) return std::nullopt;
        
        auto value = PythonConverter<T>::FromPython(this, elemResult.objectId);
        ReleaseObject(elemResult.objectId);
        
        return value;
    }
};

// Concrete implementation
class EnhancedPythonBridge : public IEnhancedPythonBridge {
    // ... implement all IPythonBridge methods ...
    // Plus the enhanced interface is inherited
};

// Usage examples
class TypeConversionExamples {
public:
    static void BasicTypes(IEnhancedPythonBridge* bridge) {
        // Set variables with automatic conversion
        bridge->SetVariable("x", 42);
        bridge->SetVariable("y", 3.14);
        bridge->SetVariable("name", std::string("Python"));
        bridge->SetVariable("flags", std::vector<bool>{true, false, true});
        
        // Get variables with type safety
        auto x = bridge->GetVariable<int>("x");
        auto y = bridge->GetVariable<double>("y");
        auto name = bridge->GetVariable<std::string>("name");
        
        if (x && y && name) {
            std::cout << "x=" << *x << ", y=" << *y << ", name=" << *name << std::endl;
        }
    }
    
    static void CustomTypes(IEnhancedPythonBridge* bridge) {
        // Work with custom types
        Point3D point{1.0, 2.0, 3.0};
        bridge->SetVariable("point", point);
        
        // Execute Python code that modifies the point
        bridge->ExecuteString("point['x'] *= 2");
        
        // Get it back
        auto modifiedPoint = bridge->GetVariable<Point3D>("point");
        if (modifiedPoint) {
            std::cout << "Modified point: (" << modifiedPoint->x << ", " 
                      << modifiedPoint->y << ", " << modifiedPoint->z << ")" << std::endl;
        }
    }
    
    static void ComplexContainers(IEnhancedPythonBridge* bridge) {
        // Nested containers
        std::map<std::string, std::vector<Point3D>> pointGroups = {
            {"group1", {Point3D{1, 2, 3}, Point3D{4, 5, 6}}},
            {"group2", {Point3D{7, 8, 9}}}
        };
        
        bridge->SetVariable("point_groups", pointGroups);
        
        // Process in Python
        bridge->ExecuteString(R"(
            # Scale all points in group1 by 2
            for i, point in enumerate(point_groups['group1']):
                point_groups['group1'][i] = {
                    'x': point['x'] * 2,
                    'y': point['y'] * 2,
                    'z': point['z'] * 2
                }
        )");
        
        // Get back
        auto result = bridge->GetVariable<std::map<std::string, std::vector<Point3D>>>("point_groups");
    }
    
    static void FunctionCalls(IEnhancedPythonBridge* bridge) {
        // Call Python functions with type safety
        auto result = bridge->CallFunction<double>("math", "sqrt", 16.0);
        if (result) {
            std::cout << "sqrt(16) = " << *result << std::endl;
        }
        
        // Call with multiple arguments
        auto power = bridge->CallFunction<double>("math", "pow", 2.0, 10.0);
        
        // Call function returning custom type
        bridge->ExecuteString(R"(
            def create_point(x, y, z):
                return {'x': x, 'y': y, 'z': z}
        )");
        
        auto point = bridge->CallFunction<Point3D>("__main__", "create_point", 
                                                   1.0, 2.0, 3.0);
    }
    
    static void MultipleReturns(IEnhancedPythonBridge* bridge) {
        // Execute code that returns multiple values
        auto results = bridge->ExecuteMultiple<int, double, std::string>(R"(
            x = 42
            y = 3.14
            z = "hello"
            (x, y, z)  # Return as tuple
        )");
        
        if (results) {
            auto [x, y, z] = *results;
            std::cout << "Got: " << x << ", " << y << ", " << z << std::endl;
        }
    }
    
    static void WithRAII(IEnhancedPythonBridge* bridge) {
        // Use RAII for automatic cleanup
        {
            auto ref = bridge->MakeRef(bridge->CreateFrom(std::vector<int>{1, 2, 3, 4, 5}));
            
            // Work with the object
            auto sum = bridge->CallMethod(ref.get(), "count", {bridge->CreateFrom(3)});
            
            // Extract value
            if (auto count = ref.as<int>()) {
                std::cout << "Count of 3: " << *count << std::endl;
            }
        }  // Automatically cleaned up
    }
};

//===============================

// UserPythonTypes.h - Example of user-defined type converters
#pragma once

#include "PythonTypeConverter.h"
#include "EnhancedPythonBridge.h"

// Example: Game development types
namespace GameTypes {
    
    // 2D Vector
    struct Vec2 {
        float x, y;
        
        Vec2(float x = 0, float y = 0) : x(x), y(y) {}
        
        Vec2 operator+(const Vec2& other) const {
            return Vec2(x + other.x, y + other.y);
        }
        
        float magnitude() const {
            return std::sqrt(x * x + y * y);
        }
    };
    
    // Color with RGBA
    struct Color {
        uint8_t r, g, b, a;
        
        Color(uint8_t r = 0, uint8_t g = 0, uint8_t b = 0, uint8_t a = 255)
            : r(r), g(g), b(b), a(a) {}
        
        uint32_t toInt() const {
            return (a << 24) | (b << 16) | (g << 8) | r;
        }
    };
    
    // Game entity
    struct Entity {
        int id;
        std::string name;
        Vec2 position;
        Vec2 velocity;
        Color color;
        std::map<std::string, float> attributes;
        
        Entity() : id(0) {}
    };
}

// Vec2 Converter
template<>
struct PythonConverter<GameTypes::Vec2> {
    static PyResult ToPython(IPythonBridge* bridge, const GameTypes::Vec2& vec) {
        // Create tuple (x, y)
        auto x = bridge->CreateFloat(vec.x);
        auto y = bridge->CreateFloat(vec.y);
        
        auto tupleType = bridge->GetObject("tuple");
        auto listArg = bridge->CreateList({x.objectId, y.objectId});
        auto result = bridge->CallMethod(tupleType.objectId, "__call__", 
                                        {listArg.objectId});
        
        bridge->ReleaseObject(tupleType.objectId);
        bridge->ReleaseObject(listArg.objectId);
        bridge->ReleaseObject(x.objectId);
        bridge->ReleaseObject(y.objectId);
        
        return result;
    }
    
    static std::optional<GameTypes::Vec2> FromPython(IPythonBridge* bridge, PyObjectId id) {
        // Handle both tuple and dict formats
        auto typeResult = bridge->CallMethod(
            bridge->GetObject("type").objectId, "__call__", {id});
        
        if (!typeResult.success) return std::nullopt;
        
        auto typeName = bridge->CallMethod(typeResult.objectId, "__name__", {});
        bridge->ReleaseObject(typeResult.objectId);
        
        if (!typeName.success) return std::nullopt;
        
        auto name = bridge->AsString(typeName.objectId);
        bridge->ReleaseObject(typeName.objectId);
        
        if (!name.has_value()) return std::nullopt;
        
        if (*name == "tuple" || *name == "list") {
            // Extract from sequence
            auto x = ExtractIndex<float>(bridge, id, 0);
            auto y = ExtractIndex<float>(bridge, id, 1);
            
            if (x && y) {
                return GameTypes::Vec2(*x, *y);
            }
        } else if (*name == "dict") {
            // Extract from dict
            auto x = ExtractKey<float>(bridge, id, "x");
            auto y = ExtractKey<float>(bridge, id, "y");
            
            if (x && y) {
                return GameTypes::Vec2(*x, *y);
            }
        }
        
        return std::nullopt;
    }
    
private:
    template<typename T>
    static std::optional<T> ExtractIndex(IPythonBridge* bridge, PyObjectId id, int index) {
        auto indexId = bridge->CreateInt(index);
        auto result = bridge->GetItem(id, indexId.objectId);
        bridge->ReleaseObject(indexId.objectId);
        
        if (!result.success) return std::nullopt;
        
        auto value = PythonConverter<T>::FromPython(bridge, result.objectId);
        bridge->ReleaseObject(result.objectId);
        return value;
    }
    
    template<typename T>
    static std::optional<T> ExtractKey(IPythonBridge* bridge, PyObjectId id, 
                                       const std::string& key) {
        auto keyId = bridge->CreateString(key);
        auto result = bridge->GetItem(id, keyId.objectId);
        bridge->ReleaseObject(keyId.objectId);
        
        if (!result.success) return std::nullopt;
        
        auto value = PythonConverter<T>::FromPython(bridge, result.objectId);
        bridge->ReleaseObject(result.objectId);
        return value;
    }
};
REGISTER_PYTHON_CONVERTER(GameTypes::Vec2, "tuple")

// Color Converter
template<>
struct PythonConverter<GameTypes::Color> {
    static PyResult ToPython(IPythonBridge* bridge, const GameTypes::Color& color) {
        // Create dict with RGBA values
        std::map<PyObjectId, PyObjectId> items;
        
        auto rKey = bridge->CreateString("r");
        auto gKey = bridge->CreateString("g");
        auto bKey = bridge->CreateString("b");
        auto aKey = bridge->CreateString("a");
        
        items[rKey.objectId] = bridge->CreateInt(color.r).objectId;
        items[gKey.objectId] = bridge->CreateInt(color.g).objectId;
        items[bKey.objectId] = bridge->CreateInt(color.b).objectId;
        items[aKey.objectId] = bridge->CreateInt(color.a).objectId;
        
        auto result = bridge->CreateDict(items);
        
        // Clean up
        bridge->ReleaseObject(rKey.objectId);
        bridge->ReleaseObject(gKey.objectId);
        bridge->ReleaseObject(bKey.objectId);
        bridge->ReleaseObject(aKey.objectId);
        for (auto& [k, v] : items) {
            bridge->ReleaseObject(v);
        }
        
        return result;
    }
    
    static std::optional<GameTypes::Color> FromPython(IPythonBridge* bridge, PyObjectId id) {
        auto r = ExtractColorComponent(bridge, id, "r");
        auto g = ExtractColorComponent(bridge, id, "g");
        auto b = ExtractColorComponent(bridge, id, "b");
        auto a = ExtractColorComponent(bridge, id, "a", 255);  // Default alpha
        
        if (r && g && b && a) {
            return GameTypes::Color(*r, *g, *b, *a);
        }
        
        return std::nullopt;
    }
    
private:
    static std::optional<uint8_t> ExtractColorComponent(IPythonBridge* bridge, 
                                                        PyObjectId id, 
                                                        const std::string& key,
                                                        uint8_t defaultVal = 0) {
        auto keyId = bridge->CreateString(key);
        auto result = bridge->GetItem(id, keyId.objectId);
        bridge->ReleaseObject(keyId.objectId);
        
        if (!result.success) {
            return defaultVal;  // Use default if key not found
        }
        
        auto value = bridge->AsInt(result.objectId);
        bridge->ReleaseObject(result.objectId);
        
        if (value.has_value()) {
            return static_cast<uint8_t>(std::clamp<int64_t>(*value, 0, 255));
        }
        
        return std::nullopt;
    }
};
REGISTER_PYTHON_CONVERTER(GameTypes::Color, "dict")

// Entity Converter (complex type)
template<>
struct PythonConverter<GameTypes::Entity> {
    static PyResult ToPython(IPythonBridge* bridge, const GameTypes::Entity& entity) {
        // Convert to Python dict
        auto idKey = bridge->CreateString("id");
        auto nameKey = bridge->CreateString("name");
        auto posKey = bridge->CreateString("position");
        auto velKey = bridge->CreateString("velocity");
        auto colorKey = bridge->CreateString("color");
        auto attrKey = bridge->CreateString("attributes");
        
        auto idVal = bridge->CreateInt(entity.id);
        auto nameVal = bridge->CreateString(entity.name);
        auto posVal = PythonConverter<GameTypes::Vec2>::ToPython(bridge, entity.position);
        auto velVal = PythonConverter<GameTypes::Vec2>::ToPython(bridge, entity.velocity);
        auto colorVal = PythonConverter<GameTypes::Color>::ToPython(bridge, entity.color);
        auto attrVal = PythonConverter<std::map<std::string, float>>::ToPython(
            bridge, entity.attributes);
        
        std::map<PyObjectId, PyObjectId> items = {
            {idKey.objectId, idVal.objectId},
            {nameKey.objectId, nameVal.objectId},
            {posKey.objectId, posVal.objectId},
            {velKey.objectId, velVal.objectId},
            {colorKey.objectId, colorVal.objectId},
            {attrKey.objectId, attrVal.objectId}
        };
        
        auto result = bridge->CreateDict(items);
        
        // Clean up all temporary objects
        std::vector<PyObjectId> temps = {
            idKey.objectId, nameKey.objectId, posKey.objectId,
            velKey.objectId, colorKey.objectId, attrKey.objectId,
            idVal.objectId, nameVal.objectId, posVal.objectId,
            velVal.objectId, colorVal.objectId, attrVal.objectId
        };
        
        for (auto id : temps) {
            bridge->ReleaseObject(id);
        }
        
        return result;
    }
    
    static std::optional<GameTypes::Entity> FromPython(IPythonBridge* bridge, PyObjectId id) {
        GameTypes::Entity entity;
        
        // Helper lambda for field extraction
        auto extractField = [bridge, id](const std::string& key, auto& target) -> bool {
            using T = std::decay_t<decltype(target)>;
            auto keyId = bridge->CreateString(key);
            auto result = bridge->GetItem(id, keyId.objectId);
            bridge->ReleaseObject(keyId.objectId);
            
            if (!result.success) return false;
            
            auto value = PythonConverter<T>::FromPython(bridge, result.objectId);
            bridge->ReleaseObject(result.objectId);
            
            if (!value.has_value()) return false;
            
            target = std::move(*value);
            return true;
        };
        
        // Extract all fields
        if (!extractField("id", entity.id)) return std::nullopt;
        if (!extractField("name", entity.name)) return std::nullopt;
        if (!extractField("position", entity.position)) return std::nullopt;
        if (!extractField("velocity", entity.velocity)) return std::nullopt;
        if (!extractField("color", entity.color)) return std::nullopt;
        if (!extractField("attributes", entity.attributes)) return std::nullopt;
        
        return entity;
    }
};
REGISTER_PYTHON_CONVERTER(GameTypes::Entity, "dict")

// Usage example
class GamePythonIntegration {
public:
    static void Example(IEnhancedPythonBridge* bridge) {
        using namespace GameTypes;
        
        // Create game entity
        Entity player;
        player.id = 1;
        player.name = "Player1";
        player.position = Vec2(100, 200);
        player.velocity = Vec2(5, 0);
        player.color = Color(255, 0, 0);  // Red
        player.attributes = {
            {"health", 100.0f},
            {"mana", 50.0f},
            {"speed", 10.0f}
        };
        
        // Send to Python
        bridge->SetVariable("player", player);
        
        // Python game logic
        bridge->ExecuteString(R"(
            import math
            
            # Move player
            player['position'] = (
                player['position'][0] + player['velocity'][0],
                player['position'][1] + player['velocity'][1]
            )
            
            # Apply damage
            player['attributes']['health'] -= 10
            
            # Change color based on health
            health_percent = player['attributes']['health'] / 100.0
            player['color']['r'] = int(255 * (1 - health_percent))
            player['color']['g'] = int(255 * health_percent)
            
            # Add new attribute
            player['attributes']['experience'] = 0
        )");
        
        // Get updated entity
        auto updated = bridge->GetVariable<Entity>("player");
        if (updated) {
            std::cout << "Player " << updated->name 
                      << " at (" << updated->position.x << ", " << updated->position.y << ")"
                      << " with " << updated->attributes["health"] << " health" << std::endl;
        }
        
        // Work with collections
        std::vector<Entity> enemies;
        for (int i = 0; i < 5; ++i) {
            Entity enemy;
            enemy.id = 100 + i;
            enemy.name = "Enemy" + std::to_string(i);
            enemy.position = Vec2(i * 50.0f, 300.0f);
            enemy.attributes = {{"health", 50.0f}};
            enemies.push_back(enemy);
        }
        
        bridge->SetVariable("enemies", enemies);
        
        // Python AI logic
        bridge->ExecuteString(R"(
            # Find closest enemy to player
            def distance(e1, e2):
                dx = e1['position'][0] - e2['position'][0]
                dy = e1['position'][1] - e2['position'][1]
                return math.sqrt(dx*dx + dy*dy)
            
            closest = min(enemies, key=lambda e: distance(e, player))
            closest['color'] = {'r': 255, 'g': 255, 'b': 0, 'a': 255}  # Yellow
        )");
    }
};

// Macro for quick converter definition
#define QUICK_CONVERTER(Type, ToPythonExpr, FromPythonExpr) \
    template<> \
    struct PythonConverter<Type> { \
        static PyResult ToPython(IPythonBridge* bridge, const Type& value) { \
            return ToPythonExpr; \
        } \
        static std::optional<Type> FromPython(IPythonBridge* bridge, PyObjectId id) { \
            return FromPythonExpr; \
        } \
    }

// Example usage of quick converter
struct Score {
    int value;
    Score(int v = 0) : value(v) {}
};

QUICK_CONVERTER(Score,
    bridge->CreateInt(value.value),
    bridge->AsInt(id).has_value() ? 
        std::optional<Score>(Score(bridge->AsInt(id).value())) : 
        std::nullopt
);

// This header can be included by users to get game type conversions
// Users can define their own types and converters in the same way
//====================

// PythonBridgeIntegration.h - Shows how type converters integrate with the ID-based system
#pragma once

#include "IPythonEnvironment.h"
#include "PythonTypeConverter.h"
#include "EnhancedPythonBridge.h"

// Extended bridge implementation showing the integration
class PythonBridgeImpl : public IEnhancedPythonBridge {
private:
    // Original ID-based storage (from earlier implementation)
    std::unordered_map<PyObjectId, PyObject*> m_objects;
    std::atomic<PyObjectId> m_nextId{1};
    std::mutex m_objectMutex;
    
    // Python contexts
    PyObject* m_mainModule = nullptr;
    PyObject* m_globalDict = nullptr;
    PyObject* m_localDict = nullptr;
    
public:
    // Original ID-based methods remain unchanged
    PyResult ExecuteString(const std::string& code) override {
        PyObject* result = PyRun_String(code.c_str(), Py_file_input, 
                                        m_globalDict, m_localDict);
        return MakeResult(result, true);
    }
    
    PyResult GetObject(const std::string& name) override {
        PyObject* obj = PyDict_GetItemString(m_globalDict, name.c_str());
        if (!obj) {
            obj = PyDict_GetItemString(m_localDict, name.c_str());
        }
        
        if (!obj) {
            PyResult result;
            result.success = false;
            result.error = "Object not found: " + name;
            result.objectId = INVALID_OBJECT_ID;
            return result;
        }
        
        return MakeResult(obj, false);
    }
    
    // ... other original methods ...
    
    // The enhanced methods use the converters but still work with IDs internally
    // This is inherited from IEnhancedPythonBridge and uses the template methods
};

// Complete usage example showing both APIs
class CompleteUsageExample {
public:
    static void DemonstrateIntegration(IEnhancedPythonBridge* bridge) {
        std::cout << "=== Type Converter Integration Demo ===" << std::endl;
        
        // 1. Original ID-based API still works
        std::cout << "\n1. Original ID-based API:" << std::endl;
        {
            auto result = bridge->ExecuteString("x = [1, 2, 3, 4, 5]");
            auto objResult = bridge->GetObject("x");
            
            if (objResult.success) {
                std::cout << "   Got object ID: " << objResult.objectId << std::endl;
                std::cout << "   Repr: " << objResult.repr << std::endl;
                
                // Manual method call
                auto sumResult = bridge->CallMethod(objResult.objectId, "count", 
                                                   {bridge->CreateInt(3).objectId});
                
                if (sumResult.success) {
                    auto count = bridge->AsInt(sumResult.objectId);
                    std::cout << "   Count of 3: " << *count << std::endl;
                    bridge->ReleaseObject(sumResult.objectId);
                }
                
                bridge->ReleaseObject(objResult.objectId);
            }
        }
        
        // 2. New type-safe API with automatic conversion
        std::cout << "\n2. Type-safe API with converters:" << std::endl;
        {
            // Direct type-safe operations
            std::vector<int> numbers = {1, 2, 3, 4, 5};
            bridge->SetVariable("numbers", numbers);
            
            // The conversion happens automatically
            auto retrieved = bridge->GetVariable<std::vector<int>>("numbers");
            if (retrieved) {
                std::cout << "   Retrieved vector with " << retrieved->size() 
                          << " elements" << std::endl;
            }
        }
        
        // 3. Custom types with converters
        std::cout << "\n3. Custom type conversion:" << std::endl;
        {
            GameTypes::Entity entity;
            entity.id = 42;
            entity.name = "Hero";
            entity.position = GameTypes::Vec2(100, 200);
            entity.attributes = {{"health", 100}, {"mana", 50}};
            
            // Automatic conversion to Python dict
            bridge->SetVariable("hero", entity);
            
            // Process in Python
            bridge->ExecuteString("hero['attributes']['health'] -= 25");
            
            // Automatic conversion back to C++
            auto updated = bridge->GetVariable<GameTypes::Entity>("hero");
            if (updated) {
                std::cout << "   Hero health after damage: " 
                          << updated->attributes["health"] << std::endl;
            }
        }
        
        // 4. Mixed usage - converters with ID access
        std::cout << "\n4. Mixed API usage:" << std::endl;
        {
            // Create complex object with converter
            std::map<std::string, std::vector<double>> data = {
                {"temperatures", {20.5, 21.0, 19.8, 22.3}},
                {"pressures", {1013.25, 1013.30, 1013.28}}
            };
            
            // This creates a Python dict internally and returns its ID
            PyObjectId dataId = bridge->CreateFrom(data);
            std::cout << "   Created object with ID: " << dataId << std::endl;
            
            // Can still use ID-based operations
            auto keysResult = bridge->CallMethod(dataId, "keys", {});
            if (keysResult.success) {
                // But can convert the result using converters
                auto keys = bridge->ExtractAs<std::vector<std::string>>(keysResult.objectId);
                if (keys) {
                    std::cout << "   Keys: ";
                    for (const auto& key : *keys) {
                        std::cout << key << " ";
                    }
                    std::cout << std::endl;
                }
                bridge->ReleaseObject(keysResult.objectId);
            }
            
            bridge->ReleaseObject(dataId);
        }
        
        // 5. Performance comparison
        std::cout << "\n5. Performance comparison:" << std::endl;
        {
            const int iterations = 1000;
            
            // Old way - manual conversion
            auto start1 = std::chrono::high_resolution_clock::now();
            for (int i = 0; i < iterations; ++i) {
                auto listId = bridge->CreateList({});
                for (int j = 0; j < 10; ++j) {
                    auto numId = bridge->CreateInt(j);
                    // Manual append... would need more code
                    bridge->ReleaseObject(numId);
                }
                bridge->ReleaseObject(listId);
            }
            auto end1 = std::chrono::high_resolution_clock::now();
            
            // New way - automatic conversion
            auto start2 = std::chrono::high_resolution_clock::now();
            for (int i = 0; i < iterations; ++i) {
                std::vector<int> vec = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
                auto id = bridge->CreateFrom(vec);
                bridge->ReleaseObject(id);
            }
            auto end2 = std::chrono::high_resolution_clock::now();
            
            auto time1 = std::chrono::duration_cast<std::chrono::microseconds>(end1 - start1).count();
            auto time2 = std::chrono::duration_cast<std::chrono::microseconds>(end2 - start2).count();
            
            std::cout << "   Manual conversion: " << time1 << "s" << std::endl;
            std::cout << "   Automatic conversion: " << time2 << "s" << std::endl;
            std::cout << "   Ratio: " << (double)time1 / time2 << "x" << std::endl;
        }
        
        // 6. Error handling
        std::cout << "\n6. Error handling:" << std::endl;
        {
            // Type mismatch
            bridge->SetVariable("string_var", std::string("not a number"));
            
            // This will safely return nullopt
            auto number = bridge->GetVariable<int>("string_var");
            if (!number.has_value()) {
                std::cout << "   Correctly failed to convert string to int" << std::endl;
            }
            
            // Can check type before conversion
            auto strResult = bridge->GetObject("string_var");
            if (strResult.success) {
                if (!bridge->CanConvertTo<int>(strResult.objectId)) {
                    std::cout << "   Type check prevented invalid conversion" << std::endl;
                }
                bridge->ReleaseObject(strResult.objectId);
            }
        }
    }
    
    // Show how the systems work together
    static void ArchitectureOverview() {
        std::cout << R"(
Architecture Overview:
=====================


                    User Application Code                     

                 IEnhancedPythonBridge API                    
                                                              
  SetVariable<T>()  GetVariable<T>()  CallFunction<R,Args>() 
                                                           

              PythonConverter<T> Templates                    
                                                              
  ToPython()  PyObjectId  FromPython()                   
                                                            

               IPythonBridge (ID-based API)                   
                                                              
  CreateInt()  CreateList()  CallMethod()  GetObject()       
                                                         

            PyObject* Storage (in .pyd module)                
                                                              
  std::unordered_map<PyObjectId, PyObject*> m_objects        
                                                             

                    Python C API                              
                                                              
  PyLong_FromLong()  PyList_New()  PyObject_CallMethod()     


Key Points:
1. Type converters are compile-time templates (zero overhead)
2. They use the ID-based API internally
3. PyObject* never crosses DLL boundaries
4. User types are automatically supported via templates
5. Both APIs can be used together when needed
)";
    }
};

// Header-only helper for users to quickly define converters
template<typename T>
class QuickConverter {
public:
    using ToPythonFunc = std::function<PyResult(IPythonBridge*, const T&)>;
    using FromPythonFunc = std::function<std::optional<T>(IPythonBridge*, PyObjectId)>;
    
    static void Register(ToPythonFunc to, FromPythonFunc from) {
        s_toPython = std::move(to);
        s_fromPython = std::move(from);
    }
    
private:
    inline static ToPythonFunc s_toPython;
    inline static FromPythonFunc s_fromPython;
    
    friend struct PythonConverter<T>;
};

// Macro for the simplest cases
#define SIMPLE_INT_CONVERTER(Type) \
    template<> \
    struct PythonConverter<Type> { \
        static PyResult ToPython(IPythonBridge* bridge, const Type& value) { \
            return bridge->CreateInt(static_cast<int64_t>(value)); \
        } \
        static std::optional<Type> FromPython(IPythonBridge* bridge, PyObjectId id) { \
            auto val = bridge->AsInt(id); \
            return val.has_value() ? std::optional<Type>(static_cast<Type>(*val)) : std::nullopt; \
        } \
    }

// Use it for enums, typedef'd ints, etc.
enum class GameState { Menu, Playing, Paused, GameOver };
SIMPLE_INT_CONVERTER(GameState);
