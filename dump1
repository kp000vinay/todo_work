#!/usr/bin/env python3
"""
ArrowFlight Python Client for communicating with the C++ relay server.
Supports sending and receiving pandas DataFrames and Arrow tables.
"""

import pyarrow as pa
import pyarrow.flight as flight
import pandas as pd
import json
import uuid
import time
from typing import Dict, List, Optional, Union, Any, Tuple
from contextlib import contextmanager
import logging


class ArrowFlightClient:
    """
    Python client for the ArrowFlight relay server.
    Handles conversion between pandas DataFrames and Arrow tables.
    """
    
    def __init__(self, host: str = "localhost", port: int = 8080, 
                 sender_id: Optional[str] = None, timeout: float = 30.0):
        """
        Initialize the ArrowFlight client.
        
        Args:
            host: Server hostname
            port: Server port
            sender_id: Unique identifier for this client
            timeout: Connection timeout in seconds
        """
        self.host = host
        self.port = port
        self.sender_id = sender_id or f"client_{uuid.uuid4().hex[:8]}"
        self.timeout = timeout
        
        # Create flight client
        location = flight.Location.for_grpc_tcp(host, port)
        self.client = flight.FlightClient(location)
        
        # Setup logging
        self.logger = logging.getLogger(f"ArrowFlightClient-{self.sender_id}")
        
        # Test connection
        self._test_connection()
    
    def _test_connection(self) -> None:
        """Test connection to the server."""
        try:
            list(self.client.list_flights())
            self.logger.info(f"Connected to ArrowFlight server at {self.host}:{self.port}")
        except Exception as e:
            raise ConnectionError(f"Failed to connect to server: {e}")
    
    @contextmanager
    def _handle_flight_errors(self, operation: str):
        """Context manager for handling Flight errors with meaningful messages."""
        try:
            yield
        except flight.FlightError as e:
            self.logger.error(f"{operation} failed: {e}")
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error during {operation}: {e}")
            raise
    
    def send_dataframe(self, key: str, df: pd.DataFrame, 
                      description: str = "DataFrame from Python") -> bool:
        """
        Send a pandas DataFrame to the server.
        
        Args:
            key: Unique identifier for the data
            df: pandas DataFrame to send
            description: Description of the data
            
        Returns:
            True if successful, False otherwise
        """
        if df.empty:
            self.logger.warning("Attempting to send empty DataFrame")
            return False
        
        try:
            # Convert DataFrame to Arrow table
            table = pa.Table.from_pandas(df)
            return self.send_table(key, table, description)
        except Exception as e:
            self.logger.error(f"Failed to convert DataFrame to Arrow table: {e}")
            return False
    
    def send_table(self, key: str, table: pa.Table, 
                   description: str = "Arrow table from Python") -> bool:
        """
        Send an Arrow table to the server.
        
        Args:
            key: Unique identifier for the data
            table: Arrow table to send
            description: Description of the data
            
        Returns:
            True if successful, False otherwise
        """
        with self._handle_flight_errors(f"sending table '{key}'"):
            # Encode metadata in descriptor path: [key, description, sender_id]
            # Clean strings to avoid path issues
            clean_description = description.replace("|", "_").replace("/", "_")
            clean_sender_id = self.sender_id.replace("|", "_").replace("/", "_")
            
            # Create flight descriptor with metadata in path
            descriptor = flight.FlightDescriptor.for_path(key, clean_description, clean_sender_id)
            
            # Convert table to record batches
            batches = table.to_batches()
            
            # Send data to server
            writer, _ = self.client.do_put(descriptor, table.schema)
            
            with writer:
                for batch in batches:
                    writer.write_batch(batch)
            
            self.logger.info(f"Successfully sent table '{key}' "
                           f"({table.num_rows} rows, {table.num_columns} columns)")
            return True
    
    def get_dataframe(self, key: str) -> Optional[pd.DataFrame]:
        """
        Retrieve a pandas DataFrame from the server.
        
        Args:
            key: Identifier of the data to retrieve
            
        Returns:
            pandas DataFrame or None if not found
        """
        table = self.get_table(key)
        if table is None:
            return None
        
        try:
            df = table.to_pandas()
            self.logger.info(f"Retrieved DataFrame '{key}' "
                           f"({len(df)} rows, {len(df.columns)} columns)")
            return df
        except Exception as e:
            self.logger.error(f"Failed to convert Arrow table to DataFrame: {e}")
            return None
    
    def get_table(self, key: str) -> Optional[pa.Table]:
        """
        Retrieve an Arrow table from the server.
        
        Args:
            key: Identifier of the data to retrieve
            
        Returns:
            Arrow table or None if not found
        """
        with self._handle_flight_errors(f"retrieving table '{key}'"):
            # Create ticket for the data
            ticket = flight.Ticket(key.encode())
            
            # Get data stream
            reader = self.client.do_get(ticket)
            
            # Read all batches and convert to table
            batches = []
            for chunk in reader:
                batches.append(chunk.data)
            
            if not batches:
                self.logger.warning(f"No data found for key '{key}'")
                return None
            
            table = pa.Table.from_batches(batches)
            self.logger.info(f"Retrieved table '{key}' "
                           f"({table.num_rows} rows, {table.num_columns} columns)")
            return table
    
    def list_tables(self) -> List[Dict[str, Any]]:
        """
        List all available tables on the server.
        
        Returns:
            List of dictionaries with table information
        """
        with self._handle_flight_errors("listing tables"):
            flights = list(self.client.list_flights())
            
            tables = []
            for flight_info in flights:
                if flight_info.descriptor.path:
                    table_info = {
                        'key': flight_info.descriptor.path[0],
                        'schema': flight_info.schema,
                        'total_records': flight_info.total_records,
                        'total_bytes': flight_info.total_bytes,
                        'endpoints': len(flight_info.endpoints)
                    }
                    tables.append(table_info)
            
            self.logger.info(f"Found {len(tables)} tables on server")
            return tables
    
    def get_server_stats(self) -> Dict[str, Any]:
        """
        Get server statistics and information about stored tables.
        
        Returns:
            Dictionary with server statistics
        """
        with self._handle_flight_errors("getting server statistics"):
            action = flight.Action("get_stats", b"")
            results = list(self.client.do_action(action))
            
            if results:
                stats_json = results[0].body.to_pybytes().decode()
                return json.loads(stats_json)
            
            return {}
    
    def clear_server(self) -> bool:
        """
        Clear all stored tables from the server.
        
        Returns:
            True if successful, False otherwise
        """
        with self._handle_flight_errors("clearing server"):
            action = flight.Action("clear_all", b"")
            results = list(self.client.do_action(action))
            
            if results:
                response = results[0].body.to_pybytes().decode()
                self.logger.info(f"Server response: {response}")
                return True
            
            return False
    
    def table_exists(self, key: str) -> bool:
        """
        Check if a table exists on the server.
        
        Args:
            key: Table identifier to check
            
        Returns:
            True if table exists, False otherwise
        """
        try:
            descriptor = flight.FlightDescriptor.for_path(key)
            self.client.get_flight_info(descriptor)
            return True
        except flight.FlightError:
            return False
    
    def wait_for_table(self, key: str, timeout: float = 30.0, 
                      poll_interval: float = 0.5) -> bool:
        """
        Wait for a table to become available on the server.
        
        Args:
            key: Table identifier to wait for
            timeout: Maximum time to wait in seconds
            poll_interval: Time between checks in seconds
            
        Returns:
            True if table becomes available, False if timeout
        """
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            if self.table_exists(key):
                self.logger.info(f"Table '{key}' is now available")
                return True
            
            time.sleep(poll_interval)
        
        self.logger.warning(f"Timeout waiting for table '{key}'")
        return False
    
    def get_table_info(self, key: str) -> Optional[Dict[str, Any]]:
        """
        Get detailed information about a specific table.
        
        Args:
            key: Table identifier
            
        Returns:
            Dictionary with table information or None if not found
        """
        try:
            descriptor = flight.FlightDescriptor.for_path(key)
            flight_info = self.client.get_flight_info(descriptor)
            
            return {
                'key': key,
                'schema': flight_info.schema,
                'total_records': flight_info.total_records,
                'total_bytes': flight_info.total_bytes,
                'endpoints': len(flight_info.endpoints),
                'columns': [field.name for field in flight_info.schema],
                'column_types': [str(field.type) for field in flight_info.schema]
            }
        except flight.FlightError:
            return None


class ArrowFlightDataExchange:
    """
    High-level utility class for data exchange between Python processes
    using the ArrowFlight relay server.
    """
    
    def __init__(self, host: str = "localhost", port: int = 8080,
                 process_id: Optional[str] = None):
        """
        Initialize the data exchange utility.
        
        Args:
            host: Server hostname
            port: Server port
            process_id: Unique identifier for this process
        """
        self.process_id = process_id or f"process_{uuid.uuid4().hex[:8]}"
        self.client = ArrowFlightClient(host, port, sender_id=self.process_id)
        
        # Setup logging
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(f"DataExchange-{self.process_id}")
    
    def publish(self, channel: str, data: Union[pd.DataFrame, pa.Table],
               description: str = "Published data") -> bool:
        """
        Publish data to a named channel.
        
        Args:
            channel: Channel name
            data: Data to publish (DataFrame or Arrow table)
            description: Description of the data
            
        Returns:
            True if successful, False otherwise
        """
        if isinstance(data, pd.DataFrame):
            return self.client.send_dataframe(channel, data, description)
        elif isinstance(data, pa.Table):
            return self.client.send_table(channel, data, description)
        else:
            raise TypeError("Data must be pandas DataFrame or Arrow Table")
    
    def subscribe(self, channel: str, as_dataframe: bool = True) -> Optional[Union[pd.DataFrame, pa.Table]]:
        """
        Subscribe to data from a named channel.
        
        Args:
            channel: Channel name
            as_dataframe: If True, return pandas DataFrame; if False, return Arrow table
            
        Returns:
            Data from the channel or None if not available
        """
        if as_dataframe:
            return self.client.get_dataframe(channel)
        else:
            return self.client.get_table(channel)
    
    def wait_and_subscribe(self, channel: str, timeout: float = 30.0,
                          as_dataframe: bool = True) -> Optional[Union[pd.DataFrame, pa.Table]]:
        """
        Wait for data to become available on a channel and then subscribe.
        
        Args:
            channel: Channel name
            timeout: Maximum time to wait
            as_dataframe: If True, return pandas DataFrame; if False, return Arrow table
            
        Returns:
            Data from the channel or None if timeout
        """
        if self.client.wait_for_table(channel, timeout):
            return self.subscribe(channel, as_dataframe)
        return None
    
    def list_channels(self) -> List[str]:
        """
        List all available data channels.
        
        Returns:
            List of channel names
        """
        tables = self.client.list_tables()
        return [table['key'] for table in tables]
    
    def get_server_status(self) -> Dict[str, Any]:
        """
        Get server status and statistics.
        
        Returns:
            Dictionary with server information
        """
        return self.client.get_server_stats()


def main():
    """Example usage of the ArrowFlight client."""
    import numpy as np
    
    # Create sample data
    df = pd.DataFrame({
        'id': range(1000),
        'value': np.random.randn(1000),
        'category': np.random.choice(['A', 'B', 'C'], 1000),
        'timestamp': pd.date_range('2024-01-01', periods=1000, freq='1H')
    })
    
    try:
        # Initialize client
        print("🚀 Connecting to ArrowFlight server...")
        client = ArrowFlightClient()
        
        # Send DataFrame
        print("📤 Sending sample DataFrame...")
        success = client.send_dataframe(
            "sample_data", 
            df, 
            "Sample data with 1000 rows"
        )
        print(f"   Send result: {'✅ Success' if success else '❌ Failed'}")
        
        # List tables
        print("\n📋 Available tables:")
        tables = client.list_tables()
        for table in tables:
            print(f"   • {table['key']}: {table['total_records']} records")
        
        # Retrieve DataFrame
        print("\n📥 Retrieving DataFrame...")
        retrieved_df = client.get_dataframe("sample_data")
        if retrieved_df is not None:
            print(f"   ✅ Retrieved DataFrame: {len(retrieved_df)} rows, {len(retrieved_df.columns)} columns")
            print(f"   Sample data:\n{retrieved_df.head()}")
        else:
            print("   ❌ Failed to retrieve DataFrame")
        
        # Get server stats
        print("\n📊 Server statistics:")
        stats = client.get_server_stats()
        print(f"   Stored tables: {stats.get('stored_tables', 'unknown')}")
        print(f"   Max capacity: {stats.get('max_capacity', 'unknown')}")
        
        # Example of high-level data exchange
        print("\n🔄 Testing high-level data exchange...")
        exchange = ArrowFlightDataExchange()
        
        # Publish data
        sample_data = pd.DataFrame({
            'x': np.random.randn(100),
            'y': np.random.randn(100)
        })
        
        exchange.publish("test_channel", sample_data, "Test data for exchange")
        
        # Subscribe to data
        received_data = exchange.subscribe("test_channel")
        if received_data is not None:
            print(f"   ✅ Data exchange successful: {len(received_data)} rows")
        else:
            print("   ❌ Data exchange failed")
        
        print("\n🎉 All tests completed!")
        
    except Exception as e:
        print(f"❌ Error: {e}")


if __name__ == "__main__":
    main()
